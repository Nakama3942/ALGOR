Так як мені легше було писати алгоритми сортування у тій початковій формі, я
завантажив ALGOR V1.0.0 та буду доробляти його. У цьому файлі будуть описані всі нові реалізовані
алгоритми. Вони тестуються у example.cpp файлі. Коли всі алгоритми будуть реалізовані, я почну
переносити їх до коду з новою побудованою системою, яка ще поки
не реалізована. Цей файл вважається чернеткою.

Було реалізовано: 8
1 день - реалізовано: 6
Залишилося: 23

Код:

#ifndef SORTINGALGORITHMS_H
#define SORTINGALGORITHMS_H

#include <iostream>
#include <ctime>
#include <random>
using namespace std;

namespace SortingAlgorithms
{
	template <class type_arr>
	class ArrayProcessing
	{
		//NOTE OLD CODE
	};

	template <class type_arr>
	class BubbleSort
	{
		//NOTE OLD CODE
	};

	template <class type_arr>
	class CocktailShakerSort
	{
		//NOTE OLD CODE
	};

	template <class type_arr> //NOTE Тут може бути й клас - треба тестувати
	class OddEvenSort
	{
	public:
		static void odd_even_sort(type_arr *Array, int array_size)
		{
			for(int i = 0; i < array_size; i++)
			{
				if(i & 1) //Непарний
				{
					for(int j = 2; j < array_size; j += 2)
					{
						if(Array[j] < Array[j - 1])
						{
							ArrayProcessing<int>::swap(Array[j - 1], Array[j]);
						}
					}
				}
				else
				{
					for(int j = 1; j < array_size; j += 2)
					{
						if(Array[j] < Array[j - 1])
						{
							ArrayProcessing<int>::swap(Array[j - 1], Array[j]);
						}
					}
				}
			}
		}
	};

	template <class type_arr> //NOTE Скоріше тут буде тип - треба тестувати
	class CombSort
	{
	public:
		static void comb_sort(type_arr *Array, int array_size)
		{
			double factor = 1.2473309; //Фактор зменшення
			int step = array_size - 1; //Шаг

			while(step >= 1)
			{
				for(int i = 0; i + step < array_size; i++)
				{
					if(Array[i] > Array[i + step])
					{
						ArrayProcessing<int>::swap(Array[i], Array[i + step]);
					}
				}
				step /= factor;
			}
		}
	};

	template <class type_arr> //NOTE Скоріше тут буде тип - треба тестувати
	class GnomeSort
	{
	public:
		static void gnome_sort(type_arr *Array, int array_size)
		{
			for(int count = 0; count < array_size; count++)
			{
				int i = 1, j = 2;

				while(i < array_size)
				{
					if(Array[i] > Array[i - 1])
					{
						i = j;
						j++;
					}
					else
					{
						ArrayProcessing<int>::swap(Array[i], Array[i - 1]);
						i--;
						if(i == 0)
						{
							i = j;
							j++;
						}
					}
				}
			}
		}
	};

	template <class type_arr>
	class QuickSort
	{
		//NOTE OLD CODE
	};

	template <class type_arr> //NOTE Скоріше тут буде тип - треба тестувати
	class StoogeSort
	{
	public:
		static void stooge_sort(type_arr *Array, int left_limit, int right_limit)
		{
			if(Array[left_limit] > Array[right_limit])
			{
				ArrayProcessing<int>::swap(Array[left_limit], Array[right_limit]);
			}
			if(left_limit + 1 >= right_limit)
			{
				return;
			}

			int k = (int)((right_limit - left_limit + 1) / 3);
			stooge_sort(Array, left_limit, right_limit - k);
			stooge_sort(Array, left_limit + k, right_limit);
			stooge_sort(Array, left_limit, right_limit - k);
		}
	};

	template <class type_arr> //NOTE Скоріше тут буде тип - треба тестувати
	class BogoSort
	{
	private:
		static bool correct(type_arr *Array, int array_size)
		{
			while(--array_size > 0)
			{
				if(Array[array_size - 1] > Array[array_size])
				{
					return true;
				}
			}
			return false;
		}
		static void shuffle(type_arr *Array, int array_size)
		{
			for(int i = 0; i < array_size; i++)
			{
				ArrayProcessing<int>::swap(Array[i], Array[rand() % array_size]);
			}
		}
	public:
		static void bogo_sort(type_arr *Array, int array_size)
		{
			while(correct(Array, array_size))
			{
				shuffle(Array, array_size);
			}
		}
	};

	template <class type_arr> //NOTE Скоріше тут буде тип - треба тестувати
	class SelectionSort
	{
	public:
		static void selection_sort(type_arr *Array, int array_size)
		{
			for(int i = 0; i < array_size; i++)
			{
				int min_index = i;

				for(int j = i + 1; j < array_size; j++)
				{
					if(Array[j] < Array[min_index])
					{
						min_index = j;
					}
				}

				if(min_index != i)
				{
					ArrayProcessing<int>::swap(Array[i], Array[min_index]);
				}
			}
		}
	};

	template <class type_arr>
	class HeapSort
	{
		//NOTE OLD CODE
	};

	//class SmoothSort{};

	template <class type_arr>
	class InsertSort
	{
		//NOTE OLD CODE
	};

	//class ShellSort{};

	//class LibrarySort{};

	//class PatienceSort{};

	//class TreeSort{};

	//class CycleSort{};

	template <class type_arr>
	class MergeSort
	{
		//NOTE OLD CODE
	};

	//class SlowSort{};

	//class StrandSort{};

	class CountingSort
	{
		//NOTE OLD CODE
	};

	//class BucketSort{};

	class RadixSort
	{
		//NOTE OLD CODE
	};

	//class PigeonholeSort{};

	//class BurstSort{};

	//class BeadSort{};

	//class PostmanSort{};

	//class TimSort{};

	//class BlockSort{};

	//class IntroSort{};

	//class SpreadSort{};

	//class TopologicalSort{};

	//class BitonicSorter{};

	//class FlashSort{};

	//class PancakeSort{};

	//class SpaghettiSort{};

	//class SampleSort{};
}

#endif // SORTINGALGORITHMS_H