# CHANGELOG

### v0.0.0.1 (29.09.2021) <- 「Alpha-release」

> *Це мала бути проста робота, що містить лише алгоритми сортування*...

#### Реліз
- Написав клас з методами генерування масиву, відображення його на екрані, заміни двох елементів місцями, знаходження максимальної та мінімальної кількості - *ArrayProcessing* та класами наступних алгоритмів сортування:
	1. **Insert_Sort**
	2. **Bubble_Sort**
	3. **Cocktail_Shaker_Sort**
	4. **Merge_Sort**
	5. **Heap_Sort**
	6. **Quick_Sort**
	7. **Counting_Sort** (на даний момент найшвидший)
	8. **Radix_Sort**

~~Старий тег 1.0.0~~

---

### v0.0.0.2 (01.10.2021) <- 「Fixes」

> *Дрібні правки*...

#### Виправлення помилок:
- Коли було побудовано база бібліотеки, все перевірялося на масивах з цілочисельними типами елементів. В результаті всі алгоритми, що використовують метод **swap()** класу *ArrayProcessing*, не працюватимуть. Крім того, останні два алгоритми сортування, як правило, розраховані лише для використання з цілочисельними типами. Я виправив усі ці помилки:
	1. Видалив шаблон там, де він не потрібен
	2. Виправив переданий тип до методу **swap()** класу *ArrayProcessing*
	3. Загалом, я виправив передані типи, де вони були неправильно вказані

~~Старий тег 1.0.1~~

---

### v0.0.0.3 (16.10.2021) <- 「Extending ArrayProcessing functionality」

> *Додано кілька нових методів*...

#### Виправлення помилок:
- А також додатково я:
	- Виправив останні опечатки та помилки, які я пропустив минулого разу;
	- Оптимізував метод **counting_sort()**, в якому тепер не копіюється знаходження мінімального та максимального елементів, а виконується виклик вже існуючих методів;
	- Додав Ліцензію та позначку, яка вказуватиме на поточну версію бібліотеки;
	- І, нарешті, оновив (виправив) приклад використання бібліотеки.

#### Покращення:
- Це оновлення спрямоване на розширення функціональності для обробки масивів, а не на сортування (майже). Нижче наведено список того, що було оновлено в класі *ArrayProcessing*:
	1. Розширено метод **print()**
	2. Змінено місцями методи **getMax()** і **getMin()**
	3. Додано методи:
		1. **reverse()** - розвертає масив
		2. **copy()** - копіює масив
		3. **sum()** - знаходить суму елементів масиву
		4. **середнє()** - знаходить середнє арифметичне масиву
		5. **mediana()** - знаходить медіану масиву
		6. **moda()** - знаходить моду масиву

~~Старий тег 1.0.2~~

---

### v0.0.1.0 (05.11.2021) <- 「Structuring」

> *Формування першої структури проекту*...

#### Виправлення помилок:
- Оптимізовано методи **getMin()** і **getMax()**. Тепер при великих розмірах масивів немає необхідності чекати, поки алгоритм пройде кожен елемент масиву, якщо зрозуміло, що найменший елемент у відсортованому масиві буде першим, а найбільший — останнім. У цих випадках достатньо вказати, чи масив є відсортованим.

#### Покращення:
- У цьому оновленні планувалося впровадити генератор, але його впровадження затягнулося. Замість цього я реалізував нову структуру для роботи з даними (масивами) і додатково розширив функціональність класу *ArrayProcessing*. Крім того, для наступних оновлень я склав план, які ще алгоритми сортування планується впровадити.
- Нова структура:
	1. Тепер масив і його розмір зберігаються в одній структурі. Це потрібно для зручності. Тепер не потрібно створювати 100 масивів і десь зберігати їх розмір. А що, якщо вони (розміри) загубляться серед десятків тисяч строк коду... Або розробник заплутається... Тепер достатньо оголосити структуру замість масиву і згенерувати її (структуру), встановивши її розмір. Тепер не потрібно зберігати розмір масиву, оскільки він тепер завжди поруч, а в більшості методів обробки масиву досить просто передати потрібну структуру, але не завжди. Існує кілька методів, як і всі алгоритми сортування, для яких потрібна не структура, а масив і його розмір окремо. У цьому випадку при виклику методу не потрібно запам'ятовувати, в якій змінній зберігається розмір якогось масиву. Тепер достатньо просто звернутися до необхідних полів структури, в якій зберігається необхідний масив. Все добре структуровано. З точки зору вивчення, тепер буде легше зрозуміти, який розмір масиву пов'язаний з яким масивом. У той же час ті, хто не знають, як передавати структури функціям, можуть навчитися цьому.
	2. Сам клас *ArrayProcessing* тепер поза межами простору імен, а сам простір імен було розділено на кілька. Кожен простір імен міститиме певні алгоритми сортування. Це необхідно для того, щоб ви могли зрозуміти, до якого типу сортування відноситься алгоритм сортування.
	3. Все-таки клас *ArrayProcessing* тепер не має свого типу шаблону. Тепер тип шаблону вказується для кожного з його методів.
- Нові методи обробки масивів:
	1. **getElementsNumber_lenear()** - лінійний пошук елемента (знаходить усі розташування цього елемента)
	2. **getElementNumber_binary()** - двійковий пошук елемента (знаходить розташування елемента в відсортованому масиві)
	3. **getOccurrencesOfSubstring()** - Пошук послідовності елементів (буде потрібно для рядків, але може використовуватися для будь-яких типів чисел, таких як int або float; повертає всі місця, де ця послідовність починається в головному масиві)
	4. **addElement()** - Додавання елемента до масиву (спочатку розширює його на одиницю, а потім записує потрібне значення в останнє місце)
	5. **generatedStruct()** - Генератор структур (отримує оголошену структуру і бажаний розмір масиву, зберігає розмір і оголошує масив з потрібним розміром)
	6. **modas()** - Пошук мод (на відміну від **moda()**, який знаходить розташування лише першого елемента, який є найбільш поширеним, він знаходить усі елементи з такою ж частотою)
- Вилучені методи:
	1. **print()**
	2. **sum()**
— Я також оновив приклад, щоб дотримуватись нових стандартів бібліотеки для роботи з масивами, і тепер все структуровано в самому прикладі: тепер кожна функція відповідає за пояснення свого бібліотечного методу і викликається з головної функції. Це зроблено для того, щоб було легше зрозуміти цю бібліотеку. Відтепер заплутатися буде важче.

~~Старий тег 1.1.0~~

---

### v0.1.0.0 (23.12.2021) <- 「Dynamization & Globalization」

> *Створив великий клас із гігантськими можливостями форматування даних у масивах*...

#### Покращення:
- Це найбільше оновлення в порівнянні з попередніми версіями. Я нарешті здійснив те, що планував з самого початку, але для чого тоді два місяці тому не мав достатнього досвіду. Нарешті я вирішив розділити оригінальний заголовок на кілька. Звісно, перед цим я вирішив, що я хочу впровадити у своїй бібліотеці в майбутньому. Це було шість розділів: *Core* (або *Base*) - база, на якій буде базуватися все інше; *Randomizer* - власна реалізація рандомайзера (необхідна для позбавлення від стандартної чи будь-якої іншої бібліотеки); *Масиви* - функції та класи для роботи з масивами; *Sorting* - алгоритми сортування; *Дерева*; *Списки*. Як уже зрозуміло, була поставлена одна з цілей: «Позбутися будь-якої зовнішньої бібліотеки - моя розробка повинна бути унікальною і написаною тільки на чистому C++ (в майбутньому можуть з'явитися вставки на мові асемблера)». Правда, пізніше для оптимізації та позбавлення від помилок був запланований додатковий клас для роботи з винятками, планувалося реалізувати матриці разом з деревами та списками, та й взагалі порядок трохи змінився. І, нарешті, лише на цьому етапі я зрозумів, як ще можна реалізувати те, що я хотів зробити два місяці тому. Я переписав функції з простору імен для роботи з масивами в клас і почав розширювати його методи. Створено базовий клас, від якого успадковуються всі методи сортування та клас обробки масивів. Так, алгоритми сортування тепер також описані в класі. У майбутньому я перебудую архітектуру класів сортування, але це не стосується цього оновлення. З гігантською класифікацією з'явилися проблеми у вигляді архітектури. Бібліотека продовжує підтримувати використання не лише класів, а й структур. Для цього я також реалізував базові функції, які можна використовувати під час роботи зі структурою, і на яких побудована більшість методів з класу, а деякі навіть використовуються при сортуванні класів. У підсумку я отримав нову архітектуру бібліотеки. Далі, на основі накопичених знань, я зміг відокремити реалізацію від декларації. Я почав розділяти реалізацію на окремі cpp-файли. Пізніше всі заголовки були об'єднані в один загальний заголовок, а всі файли реалізації були об'єднані в один файл з реалізацією. Тож я нарешті зміг відокремити реалізацію від оголошення - те, що я планував два місяці тому, але тоді не міг зробити.
- Я реалізував те, що запланував для цього оновлення: повністю перебудував архітектуру та синтаксис бібліотеки. Тепер ним ще простіше користуватися. На додаток до нової архітектури, я реалізував псевдоніми для деяких типів.
- Які функції переписані, перейменовані, а які по-справжньому нові, сказати важко. Тому я опишу це оновлення так:

	- Видалено:
		1. Клас **ArrayProcessing** з усіма його методами, але функціональність і алгоритми не викидаються на сміття, а переписуються на нові методи та функції
	
	- Нова структура проекту:
		1. *ALGOR_CORE*
		1. *ALGOR_EXCEPTION* (буде випущено у версії ~~v2.1.0~~ v0.1.1.0)
		2. *ALGOR_RANDOM*
		3. *AlGOR_SORTING* (функціонал буде розширено у версіях ~~v2.1.1 - v2.1.X~~ v0.1.1.1 - v0.1.1.X)
		4. *AlGOR_ARRAY*
		5. *ALGOR_MATRIX* (~~буде випущено у версії v2.2.0~~ почне випускатись з версії v1.0.0.0)
		6. *AlGOR_HEAP* (~~буде випущено у версії v3.0.0~~ почне випускатись з версії v2.0.0.0)
		7. *AlGOR_LIST* (~~буде випущено у версії v4.0.0~~ почне випускатись з версії v3.0.0.0)
	
	- Нові класи:
		1. *RC4* - простий криптографічний рандомайзер (його функціональність буде додатково розширена)
		2. *MersenneTwister* - розширений рандомайзер (його функціональність буде додатково розширена)
		3. *ARRAYDATA* - клас для роботи з масивами
	
	- Усі знають, як працювати з рандомайзерами. Сортування не сильно змінилося. Я опишу клас ARRAYDATA:
		1. **Constructors** - приймають структуру або розмір масиву при створенні об'єкта
		2. **generatedData()** - генерує елементи масиву
		3. **setNewData()** - видаляє старий масив і зберігає покажчик на новий
		4. **setData()** - зберігає покажчик на новий масив, не видаляючи старий
		5. **cloneData()** - копіює (клонує) масив
		6. **getData()** - встановлює/повертає покажчик на масив
		7. **reset()** - видаляє старий масив, створює новий з таким же розміром і заповнює його в тому самому діапазоні
		8. **resize()** - змінює розмір масиву
		9. **replace()** - змінює елемент у вказаній позиції на вказане значення
		10. **reverse()** - розвертає масив
		11. **remove()** - видаляє масив
		12. **respawn()** - аналог **reset()**, тільки в кінці він не заповнює масив елементами - залишає його порожнім
		13. **getMin()** - повертає мінімальне значення масиву (оптимізований метод)
		14. **getMax()** - повертає максимальне значення масиву (оптимізований метод)
		15. **lenear_searcher()** - повертає всі входження елемента, який ви шукаєте
		16. **binary_searcher()** - повертає входження потрібного елемента в відсортованому масиві
		17. **searcherOccurrencesOfSubstring()** - повертає всі входження підрядка
		18. **average()** - повертає середнє арифметичне для всіх елементів масиву
		19. **mediana()** - повертає медіану масиву
		20. **moda()** - повертає перше входження моди
		21. **modas()** - повертає всі входження моди
		22. **оператор&&()** - додає елемент в кінець масиву
		23. **оператор!()** - видаляє елемент з кінця масиву
		24. **оператор||()** - видаляє всі елементи з масиву, які відповідають заданому значенню
		25. **оператор<<()** - об'єднує два масиви в поточному об'єкті
		26. **оператор>>()** - об'єднує два масиви в зазначеному об'єкті
		27. **оператор+()** - збільшує розмір масиву на заданий розмір
		28. **оператор-()** - зменшує розмір масиву на заданий розмір
		29. **оператор*()** - збільшує розмір масиву в кілька разів на заданий розмір
		30. **оператор/()** - зменшує розмір масиву в кілька разів на заданий розмір
	
	- Нові головні функції:
		1. **swap()** - міняє місцями два елементи
		2. **minimum()** - повертає мінімальне значення масиву шляхом ітерації
		3. **maximum()** - повертає максимальне значення масиву шляхом ітерації
		4. **addElement()** - додає вказане значення до вказаної позиції
		5. **subtractElement()** - видаляє елемент у вказаній позиції
		6. **subtractValue()** - видаляє всі елементи, які відповідають вказаному значенню
		7. **copy()** - копіює елементи з одного масиву в інший
		8. **create_struct()** - створює структуру та повертає вказівник на неї
		9. **remove_struct()** - видаляє структуру
	
	- Нові типи:
		1. **int8_t, int16_t, int32_t, int64_t** (взято з stdint)
		2. **uint8_t, uint16_t, uint32_t, uint64_t** (взято з stdint)
		3. **asize_t** - "тип розміру масиву" - рідний тип для визначення типу "розмір масиву"

- Я отримав багато нового досвіду, працюючи над цим оновленням.

~~Старий тег 2.0.0~~

---

### v0.1.1.0 (11.01.2022) <- 「Exception & Safety」

> *Я подумав про безпеку зберігання даних*...

#### Виправлення помилок:
- Метод **remove()** тепер приватний. Тепер клас ARRAYDATA не може зберігати вказівник на nullptr, тому об'єкт буде постійно зберігати якийсь масив, що підвищить відмовостійкість класу ARRAYDATA.
- Додано більше перевірок і тепер, у разі помилки, програма не буде аварійно завершуватись з помилкою виконання, а викидатиме винятки, які може зловити програміст.

#### Документування:
- Я почав документувати бібліотеку. Правда, документації ще немає і знаходиться на стадії розробки. На даний момент алгоритми сортування недокументовані, а все інше задокументовано на рівні brief та param. Усі попередження, примітки, деталі тощо будуть описані після завершення розробки другої версії бібліотеки, тобто до ~~версії 3.0.0~~ головного релізу версію 1.0.0.0.

#### Покращення:
- Написав клас для роботи з винятками - Exception. Усі винятки, які створює бібліотека, тепер викидають об'єкти, успадковані від Exception, який зберігає інформацію про помилку і може повернути цю інформацію на запит програміста. Програміст також може створити власні класи винятків, успадковані від Exception.

~~Старий тег 2.1.0~~

---

### v0.1.1.1 (26.03.2022) <- 「Exchange_Sorts」

> *Завершив першу категорію алгоритмів сортування*...

#### Покращення:
- До простору імен *Selection_Sorts* додано **SelectionSort** та **SmoothSort**; **ShellSort** у *Insertion_Sorts* та всі алгоритми, що залишилися з *Exchange_Sorts*, а саме **OddEvenSort**, **CombSort**, **GnomeSort**, **SlowSort**, **StoogeSort** та **BogoSort**. Після реалізації всіх алгоритмів з *Exchange_Sorts* я нарешті отримав можливість об'єднати їх в один клас.

Тепер для виклику НЕ потрібно писати довгу команду, наприклад
```cpp
Selection_Sorts::HeapSort<int> *sort = new Selection_Sorts::HeapSort<int>(ArrayStruct);
sort->start_sort();
```
як треба було раніше для всіх інших просторів імен. Тепер достатньо ввести наступну команду
```cpp
Exchange_Sorts<int> *sort = new Exchange_Sorts<int>(ArrayStruct);
sort->Stooge_Sort(); // Or some other
```
Як бачимо, тепер достатньо створити об'єкт класу і вибрати в ньому потрібний алгоритм сортування. Тепер вам не потрібно, як раніше, вибирати клас у просторі імен і починати сортувати вже в ньому.

~~Старий тег 2.1.1~~

---

### v0.1.1.2 (30.03.2022) <- 「Selection_Sorts」

> *Завершив другу категорію алгоритмів сортування*...

#### Покращення:
- Зроблено наступний алгоритм сортування: **CycleSort**; об'єднав їх разом з **HeapSort** (всього чотири алгоритми) в один клас - *Selection_Sorts*.
- Я відмовився від **CartesianTreeSort**, **TournamentSort**, **WeakHeapSort** через їх дуже складну реалізацію та відсутність прикладів реалізацій. Можливо, колись я їх реалізую.
- Усі інші алгоритми поки згадувати не буду, бо вони ще не готові до використання. Коли їх категорія алгоритмів буде підготовлена, тоді я їх згадаю.

~~Старий тег 2.1.2~~

---

### v0.1.1.3 (01.04.2022) <- 「Insertion_Sorts」

> *Завершив третю категорію алгоритмів сортування*...

#### Покращення:
- Я реалізував наступні алгоритми сортування: **TreeSort**, **PatienceSort** та **LibrarySort** та об'єднав їх із **InsertSort** (окрім **LibrarySort**) в один клас. Оскільки я не можу обійтися без стандартних бібліотек у **LibrarySort**, я вирішив зробити його окремим класом. Це ускладнило структуру та поділ бібліотеки на два варіанти - із стандартними бібліотеками та без них. Тепер у верхній частині заголовка будуть налаштування. Залежно від значення #define STANDARDS_SWITCH, бібліотека буде скомпільована з цими алгоритмами або без них, що потребують стандартних бібліотек. "0" - без бібліотек, "1" - з бібліотеками. Оскільки бібліотека спочатку була задумана як чистий проект без використання будь-якої стандартної чи будь-якої іншої бібліотеки, я не збираюся далі розвивати цю сферу. У цьому розділі будуть зібрані деякі алгоритми сортування, які потрібні цим стандартним бібліотекам, і не більше. Все інше мені доведеться реалізувати самому. Оскільки вже є багато реалізованих алгоритмів сортування, я можу собі це дозволити. Не виключено, що в майбутньому, завдяки впровадженню системи налаштувань, структура проекту ставатиме дедалі складнішою. Звичайно, я не буду випускати цей продукт зі стандартними бібліотеками, але залишу їх у разі потреби. Якщо програмісту потрібен саме той алгоритм, який використовує стандартні бібліотеки - він завжди може завантажити репозиторій і зібрати бібліотеку з необхідними налаштуваннями.
- На випадок, якщо програміст буде використовувати розділ зі стандартними бібліотеками, мені довелося розмістити деякі стандартні функції в класі Core, щоб уникнути конфліктів.

~~Старий тег 2.1.3~~

---

### v0.1.1.4 (04.04.2022) <- 「Merge_Sorts」

> *Завершив четверту категорію алгоритмів сортування*...

#### Покращення:
— Я спробував почитати про **CascadeMergeSort**, **OscillatingMergeSort** та **PolyphaseMergeSort**, але інформації про них майже немає (навіть у Вікіпедії). Я вирішив відмовитися від цих алгоритмів і виявилося, що в цій категорії є тільки один алгоритм, який вже реалізований. Я переписав його на новий стандарт і випустив новий випуск.

~~Старий тег 2.1.4~~

---

### v0.1.2.0 (15.04.2022) <- 「namespace ALGOR & Comparative_Sorts & Distribution_Sorts」

> *Після завершення п'ятої категорії алгоритмів сортування я подумав про глобальний простір імен усього проекту*...

#### Покращення:
- Починаючи з версії ~~v1.0.0~~ v0.0.0.1, лише **CountingSort** та **RadixSort** були реалізовані з категорії *Distribution_Sorts*. Нарешті я завершив останню групу тих алгоритмів, які були присутні з самого початку. Я реалізував **AmericanFlagSort**, **BeadSort**, **BucketSort**, **FlashSort**, **InterpolationSort**, **PigeonholeSort** і відмовився від **BurstSort** та **ProxmapSort**. Мені залишилося реалізувати 3 інші категорії, які не були реалізовані з самого початку і донині: *Concurrent_Sort*, *Hybrid_Sorts* та *Other_Sorts*.
- З реалізацією цієї категорії я придумав функцію, яка призначена для заміни **time(NULL)** (ну, нарешті), а також перевизначив функції **minimum()** і **maximum()** - тепер вони повертають не тільки найменше/найбільше число, знайдене в масиві, а й найменше/найбільше з двох заданих значень. Поширення функцій, не пов'язаних із масивом, призвело до розділення функцій з ядра на функції, пов'язані з масивами та не пов'язані з масивами. Останній залишився в ядрі, тоді як перший перемістився до підрозділу обробки масивів, а оскільки базові класи сортування (наприклад, категорії) успадковані від базового класу масиву, підрозділ обробки масиву в цілому перемістився з "під" розділу алгоритмів сортування на "над" розділ сортування.
- Потім я об'єднав в один клас усі загальні класи алгоритмів сортування, які можуть сортувати не тільки int-масиви. Тепер у підрозділі алгоритмів сортування є лише два класи алгоритмів сортування: ті, що підтримують будь-які типи масивів, і ті, що працюють тільки з int-масивами. Тимчасово, на момент впровадження останніх категорій алгоритмів сортування, три останні класи з наступними трьома оновленнями будуть випущені окремими класами, але після цього планується об'єднати їх з першим класом.
- І, нарешті, я доопрацював систему налаштувань. Тепер ядро бібліотеки, винятки та рандомайзери не можна вимкнути для компілятора, проте вже можна вимкнути підсекції обробки та сортування масивів. Також можна буде вмикати та вимикати на компіляцію додаткові алгоритми та структури даних, які будуть реалізовані в майбутньому. Наприкінці випусків із реалізацією алгоритмів сортування я планую повернутися до **LibrarySort** і все одно реалізувати власні аналоги **std::distance()** і **std::lower_bound()**, щоб повернути цей алгоритм до бібліотеки на постійно і надати до нього повний доступ. Якщо мені вдасться це зробити - я можу повністю відмовитися від підрозділу зі стандартними бібліотеками (що було початковою ідеєю проекту), якщо туди не потрапить ще кілька алгоритмів сортуваннь...
- Я майже забув - оскільки у ~~v2.1.3~~ v0.1.1.3 була представлена нова структура проекту, можна вважати, що зараз вона повністю доопрацьована. Потім був доданий **LibrarySort**, і щоб уникнути конфліктів імен, мені довелося повернути головні функції класу. Однак тепер я додав всю бібліотеку загалом до свого власного простору імен *ALGOR* (як у версії ~~v1.0.0~~ v0.0.0.1 це було з *SortingAlgorithms*, в якому клас **ArrayProcessing** був вкладений зі статичними методами і восьма алгоритмами сортування (3 з *Exchange_Sorts*, 1 з *Selection_Sorts*, 1 з *Insertion_Sorts*, 1 з *Merge_Sorts* і 2 з *Distribution_Sorts*) - це дуже схоже на структуру з цієї версії). Я перемістив головні функції за межі головного класу, і цей клас залишився для зберігання головних функцій обробки масиву і перейшов до підрозділу обробки масиву. Тепер, щоб використовувати мою бібліотеку, вам потрібно або постійно вказувати ідентифікатор простору імен *ALGOR*, або оголосити його основним на початку проекту і використовувати *std* до мінімуму, наприклад, для друку тексту в консолі або для використання функцій, якох немає в моїй бібліотеці.

Тепер неможливо використовувати:
```cpp
using namespace std;
using namespace ALGOR;
```
Це не залежить від порядку. Вам потрібно лише вибрати один з них! Це завершення структурного оновлення.

~~Старий тег 2.2.0~~

---

### v0.1.2.1 (03.06.2022) <- 「Completed sorting algorithms」

> *Достроково виконав останню шосту, сьому та восьму категорії алгоритмів сортування та "прєісполнился в познаніі" вказівників*...

#### Покращення:
- Я забув, що на початку оновлень сортування я іноді робив прості алгоритми з послідуючих категорій алгоритмів сортування. Я думав, що у мене всього 26 алгоритмів сортування, забувши про 3 алгоритми сортування, які вже реалізовані, але не переписані до останньої версії стандарту проектування, і про алгоритм, який використовує дві стандартні функції. Я просто втомився і хотів випустити 30-35 алгоритмів сортування, а мав тільки 26 офіційно завершених алгоритмів, тобто мені ще залишалося реалізувати ще 4-9 алгоритмів зі списку у 10 нереалізованих алгоритмів. Згадавши, що у мене є 4 реалізованих, але не завершених алгоритми, я отримую всього 30 алгоритмів, які й запланував. Я вирішив зупинитися на цьому. Щоб реалізувати алгоритм сортування **Library_Sort**, мені потрібно було написати власні реалізації стандартних функцій **distance()** і **lower_bound()**. Я намагався це зробити і раніше, але тоді у мене не вийшло. Тоді я витратив на це два дні. Минув час, я багато чому навчився і вирішив спробувати написати ці функції ще раз. І на мій великий подив, я написав їх реалізацію з першого разу. Потім я протестував ці функції, зробив доступною приховану функцію **verification()**, яку я назвав **array_size_verification()**. І в кінці я вирішив реалізувати функцію, подібну до **lower_bound()**, а саме **upper_bound()**. В результаті:
	- Я додаю нові функції:
		1. **array_size_verification()** - створює виняток, якщо масив порожній (тобто його розмір дорівнює нулю)
		2. **distance()** - повертає відстань між початком і кінцем вказаного діапазону масиву
		3. **lower_bound()** - повертає вказівник на перше входження вказаного значення у заданому діапазоні (масив потрібно відсортувати; функція схожа на двійковий пошук)
		4. **upper_bound()** - повертає вказівник на перше входження наступного значення після вказаного у заданому діапазоні (масив потрібно відсортувати; функція, схожа на двійковий пошук)
	- Я закінчив:
		- Алгоритм сортування **Bitonic_Sorter** з категорії *ConcurrentSort*
		- Алгоритм сортування **Tim_Sort** з категорії *HybridSorts*
		- Алгоритм сортування **Pancake_Sort** з категорії *OtherSorts*
		- Алгоритм сортування **Library_Sort** з категорії *InsertionSorts*
	- Я видалив налаштування: оскільки у мене більше немає розділу зі стандартними бібліотеками - у мене більше немає мети ділити проект на розділи, які можна включити і виключити на компіляцію.
- Зауважу, що алгоритми сортування вже були реалізовані на момент випуску оновлення ~~v2.0.0~~ v0.1.0.0, а тому ці десять, які залишилися реалізувати після випуску цього оновлення, більше не будуть реалізовані. Десять нереалізованих алгоритмів сортування: **BatcherOddEvenMergeSort** з *ConcurrentSort*, **PairwiseSortingNetwork** з *ConcurrentSort*, **SampleSort** з *ConcurrentSort*, **BlockMergeSort** з *HybridSorts*, **KirkpatrickReischSort** з *HybridSorts*, **IntroSort** з *HybridSorts*, **SpreadSort** з *HybridSorts*, **MergeInsertionSort** з *HybridSorts*, **TopologicalSort** з *OtherSorts*, **SpaghettiSort** з *OtherSorts*. Я просто втомився від цього. Я хочу чогось нового.

~~Старий тег 2.2.1~~

---

### v0.1.3.0 (24.06.2022) <- 「Completed develop arrays structuring and library core」

> *Довів структуру проекту до остаточного вигляду*...

#### Виправлення непрацездатного функціоналу:
- Замінив непрацюючий *SmoothSort* на *BatcherOddEvenMergeSort*.

#### Документування:
- Повернув усе документування назад у хідер. Готуюсь до написання документації;
- Переписав CHANGELOG під новий стиль оформлення.

#### Покращення:
- Додано:
	- Додав окрему функцію генерування масивів, яку використовує клас;
	- Додав нові Ґеттери: **getPosition()** та **getValue()**;
	- Додав Лінійний Конґруентний Метод ГПСЧ та функцію тестування Рандомізаторів на рівномірність генерування чисел, використовуючи критерій узгодженості Пірсона;

- Оптимізовано:
	- Оптимізував функцію **swap()**;
	- Сильно оптимізував метод **resize()**;

- Замінено:
	- Замінив реалізації методів **reset()** та **respawn()** місцями;
	- Замінив бінарний пошук (тепер він схожий на той бінарний пошук, що було реалізовано для _LibrarySort_);

- Переписано:
	- Переписав усі стандартні типи на оголошені аліаси;
	- Переписав гігантську частину коду, замінивши примусову компіляцію методів на примусову компіляцію класів;
	- Визначився з типами, з якими тепер будуть компілюватися функції та класи (_**byte8_t** == long long int_, _**ubit64_t** == unsigned long long int_, _**fbit64_t** == double_, _**fbit128_t** == long double_, _**asize_t** == unsigned int_);
	- Повністю переписав старі оператори (у деяких змінив навіть призначення) та додав нових: ^=, =, ==;

- Тестування:
	- Написав окремі програми для тестування бібліотеки;
	- Повністю протестував всі алгоритми сортування;

- Перевірка масиву:
	- Функція верифікації доведена до остаточного виду: тепер це метод базового класу масивів, що використовується при збереженні до об'єкту класу данних;

- Об'єднано:
	- Об'єднав усі базові функції до базового класу, переписавши їх під статичні методи;
	- Об'єднав методи **moda()** та **modas()** до одного методу, так як я створив для них їх власну структуру й обидві вони тепер повертають вказівник на цю структуру, а другий метод використовує перший і трохи поширює результат (так який у цьому сенс, якщо їх об'єднати - нічого не зміниться);
	- Об'єднав усі виключення в простір імен *EXCEPTION_SET*;
	- Об'єднав усі Рандомізатори в простір імен *RANDOM*;
	- Об'єднав обидві категорії (класи) сортувань в простір імен *SORTING*;

- Ререліз:
	- Замінив версії релізів (тепер реліз бібліотеки версії *1.0.0.0* відбудеться тільки після завершення повного документування).

~~Запланований старий тег 2.3.0~~

---

### v1.0.0.0 (DATE) Документування [--- не завершене ---] {головна розробка завершена; проект готовий додавати новий вміст}

> *-*...

#### Bug Fixes:
- [# XXX](https : / / github . com / XXX) DESCRIPTION

#### Invalid Fixed:
- [# XXX](https : / / github . com / XXX) DESCRIPTION

#### Documenting:
- [# XXX](https : / / github . com / XXX) DESCRIPTION

#### Duplicating:
- [# XXX](https : / / github . com / XXX) DESCRIPTION

#### Enhancements:
- [# XXX](https : / / github . com / XXX) DESCRIPTION

~~Запланований старий тег 2.4.0~~