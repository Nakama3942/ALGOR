/* **************************   DOCUMENTATION.dox   ************************** *
 * --------------------------------------------------------------------------- *
 *                                                                             *
 * Copyright © 2022 Kalynovsky Valentin. All rights reserved.                  *
 *                                                                             *
 * Licensed under the Apache License, Version 2.0 (the "License");             *
 * you may not use this file except in compliance with the License.            *
 * You may obtain a copy of the License at                                     *
 *                                                                             *
 *     http://www.apache.org/licenses/LICENSE-2.0                              *
 *                                                                             *
 * Unless required by applicable law or agreed to in writing, software         *
 * distributed under the License is distributed on an "AS IS" BASIS,           *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    *
 * See the License for the specific language governing permissions and         *
 * limitations under the License.                                              *
 *                                                                             *
 * --------------------------------------------------------------------------- *
 * *************************************************************************** *
 */

/*!
  \namespace ALGOR
  \brief Глобальний простір імен усього проекту
  \details Призначений для зберігання усього реалізованого функціоналу проекту.
  Краще не використовувати разом з std, інакше можуть виникнути конфлікти.
  \since v0.1.2.0 commit 2fa93b
  \example sort_global.cpp
  \example sort_test.cpp
  \example Algor_core.cpp
  \example Algor_printer.cpp
  \example Algor_exception.cpp
  \example Algor_random.cpp
  \example Algor_ArrayProcessing.cpp
  \example Algor_ArrayData.cpp
  \example Algor_ArraySort.cpp
 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                  ALGOR_CORE                                 *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

	/*!
	   \typedef ALGOR::byte1_t
	   \brief Аліас для char <em>(1 байт)</em>.
	   \details Зазвичай використовується для задання типу строк. Може зберігати
	   число від <b>0</b> до <b>255</b>, або від <b>-128</b> до <b>+127</b>.
	   \since v0.1.3.0 commit b50b4a
	   \note Якщо цей тип дійсно використовується для строк, то не забувайте
	   вказувати "*" (вказівник) перед назвою імені строки, так як цей тип
	   не замінює повністю char на string. Це лише звичайний аліас.
	 */
	 
	/*!
	   \typedef ALGOR::byte2_t
	   \brief Аліас для short <em>(2 байти)</em>.
	   \details Зазвичай використовується при зберіганні коротких чисел
	   від <b>0</b> до <b>65'535</b>, або від <b>-32'768</b> до <b>+32'767</b>.
	   \since v0.1.3.0 commit b50b4a
	 */

	/*!
	   \typedef ALGOR::byte4_t
	   \brief Аліас для long <em>(4 байти)</em>.
	   \details Зазвичай використовується при зберіганні чисел. Може
	   зберігати від <b>0</b> до <b>4'294'967'295</b>, або від <b>-2'147'483'648</b>
	   до <b>+2'147'483'647</b>.
	   \since v0.1.3.0 commit b50b4a
	   \note Також ним можна повноцінно замінити тип int, так як він теж
	   розрахований на 4 байти. Але якщо програму запустити на комп'ютері
	   з процесором intel i386 чи більш ранішим, то під int буде виділятися усього
	   2 байти і на тих процесорах int є аліасом для short. Через таке розпливчате
	   поняття типу int він ніде у бібліотеці не використовується, а використовуються
	   чіткі типи типу short чи long.
	 */

	/*!
	   \typedef ALGOR::byte8_t
	   \brief Аліас для long long <em>(8 байтів)</em>.
	   \details Є розширенням типу long у два рази і розрахований під числа від <b>0</b>
	   до <b>18'446'744'073'709'551'615</b>, або від <b>-9'223'372'036'854'775'808</b>
	   до <b>+9'223'372'036'854'775'807</b>.
	   \since v0.1.3.0 commit b50b4a
	 */

	/*!
	   \typedef ALGOR::sbit8_t
	   \brief Аліас для signed char <em>(1 байт)</em>.
	   \details Аналогічно звичайному char, але може приймати значення тільки
	   від <b>-128</b> до <b>+127</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::sbit16_t
	   \brief Аліас для signed short <em>(2 байти)</em>.
	   \details Аналогічно звичайному short, але може приймати значення тільки
	   від <b>-32'768</b> до <b>+32'767</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::sbit32_t
	   \brief Аліас для signed long <em>(4 байти)</em>.
	   \details Аналогічно звичайному long, але може приймати значення тільки
	   від <b>-2'147'483'648</b> до <b>+2'147'483'647</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::sbit64_t
	   \brief Аліас для signed long long <em>(8 байтів)</em>.
	   \details Аналогічно звичайному long long, але може приймати значення тільки
	   від <b>-9'223'372'036'854'775'808</b> до <b>+9'223'372'036'854'775'807</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::ubit8_t
	   \brief Аліас для unsigned char <em>(1 байт)</em>.
	   \details Аналогічно звичайному char і на відміну від signed char може
	   приймати значення тільки від <b>0</b> до <b>255</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::ubit16_t
	   \brief Аліас для unsigned short <em>(2 байти)</em>.
	   \details Аналогічно звичайному short і на відміну від signed short може
	   приймати значення тільки від <b>0</b> до <b>65'535</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::ubit32_t
	   \brief Аліас для unsigned long <em>(4 байти)</em>.
	   \details Аналогічно звичайному long і на відміну від signed long може
	   приймати значення тільки від <b>0</b> до <b>4'294'967'295</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::ubit64_t
	   \brief Аліас для unsigned long long <em>(8 байтів)</em>.
	   \details Аналогічно звичайному long long і на відміну від signed long long
	   може приймати значення тільки від <b>0</b> до <b>18'446'744'073'709'551'615</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::fbit32_t
	   \brief Аліас для float <em>(4 байти)</em>.
	   \details На відміну від всіх попередніх типів, що можуть зберігати тільки
	   цілі числа, тип \a float може зберігати числа з плаваючою комою. У
	   комірку можна записати як додатні, так і від'ємні числа. Можливий діапазон
	   зберігаємих чисел від <b>+/-3.4E-38</b> до <b>3.4E+38</b>.
	   \since v0.1.2.0 commit 1981d6
	 */

	/*!
	   \typedef ALGOR::fbit64_t
	   \brief Аліас для double <em>(8 байтів)</em>.
	   \details Розширює тип \a float, збільшуючи точність та розмір у два рази.
	   Можливий діапазон зберігаємих чисел від <b>+/-1.7E-308</b> до <b>1.7E+308</b>.
	   \since v0.1.2.0 commit 1981d6
	 */

	/*!
	   \typedef ALGOR::fbit128_t
	   \brief Аліас для long double <em>(16 байт)</em>.
	   \details Розширює тип \a double, збільшуючи точність та розмір іще у два
	   рази.
	   \since v0.1.3.0 commit b6349a
	 */

	/*!
	   \typedef ALGOR::asize_t
	   \brief Псевдонім для визначення типу <em>"розмір массиву"</em>.
	   \details Зазвичай цей тип використовується, коли треба вказати розмір масиву
	   чи позицію у масиві. Так як нумерація починається з 0 і не існує від'ємних
	   розмірів масивів чи номерів позицій, можна поточнити тип з <a>int</a> до
	   <a>unsigned int</a>. До того ж не завжди вистачає <b>65'535</b> комірок масиву.
	   Іноді потрібно більше, наприклад, мільйон чи мільярд. Більше мільярда нема
	   сенсу створювати структури даних тому ідеальним вибором серед <a>short</a>,
	   <a>long</a> та <a>long long</a> є <a>long</a>. Саме тому <a>asize_t</a> є
	   аліасом до <a>ubit32_t</a>.
	   \since v0.1.0.0 commit 89658e
	 */

	/*!
	   \typedef ALGOR::memcell_t
	   \brief Псевдонім для обчислюваної <em>комірки пам'яті</em>.
	   \details використовується тільки у функції \a getMemoryCell(). Є службовим типом
	   і замість нього краще використовувати \a ubit64_t.
	   \since v0.1.1.3 commit b4cdc9
	 */

	/*!
	   \fn ALGOR::swap(type_value &, type_value &)
	   \brief Міняє місцями два елементи
	   \details Функція приймає два значення, які треба замінити місцями. Після
	   виконання функції перша комірка пам'яті буде зберігати друге значення, а
	   друга - перше. Для виконання алгоритму використовується додаткова
	   комірка пам'яті.
	   \tparam type_value Тип елементів, що міняються місцями
	   \param[in, out] firstNumber Перший елемент для заміни
	   \param[in, out] secondNumber Другий елемент для заміни
	   \since v0.0.0.1
	   \test
	   \snippet Algor_core.cpp swap
	 */

	/*!
	   \fn ALGOR::minimum(type_value, type_value)
	   \brief Шукає найменше значення з двух наданих
	   \details Функція приймає два значення і порівнює їх. Якщо перше
	   число виявится меншим за друге - функція повертає перше число, інакше -
	   друге.
	   \tparam type_value Тип елементів, з яких вибирається найменше значення
	   \param[in] firstNumber Перше значення на вибірку
	   \param[in] secondNumber Друге значення на вибірку
	   \since v0.1.1.4 commit 090b06
	   \return найменше значення з двух наданих
	   \test
	   \snippet Algor_core.cpp minimum
	 */

	/*!
	   \fn ALGOR::maximum(type_value, type_value)
	   \brief Шукає найбільше значення з двух наданих
	   \details Функція приймає два значення і порівнює їх. Якщо перше
	   число виявится більшим за друге - функція повертає перше число, інакше -
	   друге.
	   \tparam type_value Тип елементів, з яких вибирається найбільше значення
	   \param[in] firstNumber Перше значення на вибірку
	   \param[in] secondNumber Друге значення на вибірку
	   \since v0.1.1.4 commit 090b06
	   \return найбільше значення з двух наданих
	   \test
	   \snippet Algor_core.cpp maximum
	 */

	/*!
	   \fn ALGOR::getMemoryCell(memcell_t, memcell_t)
	   \brief Повертає випадкове число; аналог time(NULL)
	   \details Цей метод виділяє пам'ять під 10 комірок пам'яті. Куди саме система
	   виділить пам'ять передгадати неможливо, а також неможливо передгадати, яка
	   програма і які данні раніше сюди записувала, тому це самий реальний генератор
	   випадкович чисел. Поки генерація масивів не була доведена до ідеалу, але як
	   генераточ великого числа замість time(NULL) цілком реально використати. Із
	   десяти випадкових чисел функція розраховує число, яке треба повернути.
	   \param[in] right_adjust Правий здвиг
	   \param[in] left_adjust Лівий здвиг
	   \since v0.1.1.3 commit b4cdc9
	   \remark Функції можна задати бітовий здвиг. Якщо функція використовується
	   замість time(NULL), а результат передається у іншу функцію, що приймає тільки
	   чотири-байтове значення, можна задати правий здвиг на 32 біти (4 байти) і
	   тоді функція поверне 4 старших байти.
	   \retval cell - розраховане випадкове число
	   \test
	   \snippet Algor_core.cpp mem
	 */

	/*!
	   \interface ALGOR::Printer
	   \brief Printer-інтерфейс, призначений для реалізації функціоналу виводу
	   інформації
	   \details Це є інтерфейс, що складається лише з одного віртуального методу, який
	   призначений для виводу інформації. Так як цей проект є унікальним у тому сенсі,
	   що не використовується жодна інша бібліотека (навіть стандартна) і автор
	   власноруч пише власну реалізацію алгоритмів - тому неможливо використати
	   клас iostream, через що неможлива реалізація принтеру. Автору потрібно буде з
	   початку написати власний клас вводу-виводу, а в умовах популярності графічних
	   інтерфейсів це не є оптимальним та актуальним. Краще програмісту самому дати
	   реалізувавти ввод-вивід. До того ж такий метод є універсальним: його можна
	   використовувати й у консольних програмах, й у графічних. Якби я намагався
	   власноруч написати реалізацію, вона була б спеціалізованою чи під консоль, чи
	   під графіку. Саме це мене підштовхнуло написати саме інтрерфейс, а не клас.
	   \since v0.1.2.0 commit 2fa93b
	   \remark
	   Раджу використовувати наступну реалізацію для консольної програми:
	   \test
	   \snippet Algor_printer.cpp printer
	   Цей клас зберігає не матрицю, а вказівник на вказівник на структуру масиву.
	   Тому достатньо один раз передати у клас вказівник на структуру і все. Далі
	   можна просто міняти вказівники на інші структури з іншими масивами і не
	   треба їх заново передавати у цей клас. Він сам буде відстежувати, який
	   вказівник зберігається у вказівнику на структуру.
	 */

		/*!
		   \fn ALGOR::Printer::print()
		   \brief Метод для виводу інформації
		   \since v0.1.2.0 commit 2fa93b
		   \test
		   \snippet Algor_printer.cpp print
		 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                               ALGOR_EXCEPTION                               *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

	/*!
	  \namespace ALGOR::EXCEPTION_SET
	  \brief Простір імен, що реалізовує виключення
	  \details Простір імен являє собою набір класів, які використовуються при киданні
	  виключень, так як зберігають необхідну інформацію про випадок, що стався. Головний
	  клас \a Exception являє собою каркас винятка, який можна успадкувати для
	  полегшення роботи з винятками. Можна дати додаткову інформацію до вже реалізованих
	  класів-нащадків, а можна створити власні класи-нащадки.
	  \since v0.1.3.0 commit 2cdff0
	 */

		/*!
		   \class ALGOR::EXCEPTION_SET::Exception
		   \brief Клас-каркас для роботи з винятками
		   \details Клас, що зберігає данні про виняток (номер винятка, деталі та
		   пояснення). Щоб створити об'єкт винятку достатньо переадти необхідні данні
		   конструктору, а для отримання інформації про виняток треба його перехопити
		   і використати метод, що повертає необхідні данні.
		   \since v0.1.1.0 commit c62e85
		   \test
		   \snippet Algor_exception.cpp exception code details explanation class
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::Exception(ubit16_t, const byte1_t *, const byte1_t *)
			   \brief Розширений конструктор класу винятків
			   \details Конструктор, що приймає розширену кількість данних, а саме код
			   винятку, деталі винятку, та пояснення до деталей, що не завжди буває
			   необхідним.
			   \param[in] CODE Код Exception
			   \param[in] DETAILS Деталі Exception
			   \param[in] EXPLANATION Пояснення Exception
			   \since v0.1.3.0 commit 2c6408
			   \remark Цей конструктор є розширеним так як дозволяє успадкованим класам
			   надати пояснення до винятку, коли це необхідно, що робить цей клас
			   більш універсальним.
			   \test
			   \snippet Algor_exception.cpp exception code details explanation
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::Exception(ubit16_t, const byte1_t *)
			   \brief Стандартний конструктор класу винятків
			   \details Конструктор, що приймає базову кількість данних про виняток.
			   Зазвичай номеру та деталей помилки буває достатньо.
			   \param[in] CODE Код Exception
			   \param[in] DETAILS Деталі Exception
			   \since v0.1.1.0 commit c62e85
			   \test
			   \snippet Algor_exception.cpp exception code details
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::Exception(ubit16_t)
			   \brief Скорочений кодовий конструктор класу винятків
			   \details Конструктор, що приймає скорочену кількість данних про
			   виняток. Єдині данні, що зберігаються у об'єкті винятку, це номер
			   винятку.
			   \param[in] CODE Код Exception
			   \since v0.1.1.0 commit c62e85
			   \test
			   \snippet Algor_exception.cpp exception code
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::Exception(const byte1_t *)
			   \brief Скорочений детальний конструктор класу винятків
			   \details Конструктор, що приймає скорочену кількість данних про
			   виняток. Єдині данні, що зберігаються у об'єкті винятку, це деталі
			   винятку.
			   \param[in] DETAILS Деталі Exception
			   \since v0.1.1.0 commit c62e85
			   \test
			   \snippet Algor_exception.cpp exception details
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::code()
			   \brief Метод, що повідомляє номер винятку
			   \details Повертає номер винятку, що зберігається в об'єкті.
			   \since v0.1.1.0 commit c62e85
			   \retval CODE - номер винятку
			   \test
			   \snippet Algor_exception.cpp exception catch code
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::what()
			   \brief Метод, що повідомляє деталі винятку
			   \details Повертає деталі винятку, що зберігаються в об'єкті.
			   \since v0.1.1.0 commit c62e85
			   \retval DETAILS - деталі винятку
			   \test
			   \snippet Algor_exception.cpp exception catch details
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::why()
			   \brief Метод, що дає пояснення винятку
			   \details Повертає пояснення винятку, що зберігається в об'єкті.
			   \since v0.1.3.0 commit 2c6408
			   \retval EXPLANATION - пояснення винятку
			   \test
			   \snippet Algor_exception.cpp exception catch explanation
			 */

			/*!
			   \var ALGOR::EXCEPTION_SET::Exception::CODE
			   \brief Номер винятку
			   \since v0.1.1.0 commit c62e85
			 */

			/*!
			   \var ALGOR::EXCEPTION_SET::Exception::DETAILS
			   \brief Деталі винятку
			   \since v0.1.1.0 commit c62e85
			 */

			/*!
			   \var ALGOR::EXCEPTION_SET::Exception::EXPLANATION
			   \brief Пояснення винятку
			   \since v0.1.3.0 commit 2c6408
			 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep55
		   \brief Повідомлення для memory_overflow
		   \since v0.1.3.0 commit d66e53
		   \par Текст повідомлення
		   <em>"Комірка пам'яті, в якій зберігається розмір обсягу даних, більше
		   не може зберігати більше. Ця помилка може виникнути у випадках, коли
		   в комірку, яка може зберігати змінну 0xffffffff, потрібно записати
		   більше значення, тобто більше 4 байт, оскільки клітинка зберігання
		   даних займає 4 байти"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep101
		   \brief Повідомлення для division_by_zero
		   \since v0.1.3.0 commit d66e53
		   \par Текст повідомлення
		   <em>"Відбулося ділення на нуль - невизначений результат виконання
		   програми"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep254
		   \brief Повідомлення для position_failure
		   \since v0.1.3.0 commit d66e53
		   \par Текст повідомлення
		   <em>"Помилка позиції - позиція відсутня в масиві"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep255
		   \brief Повідомлення для value_failure
		   \since v0.1.3.0 commit d66e53
		   \par Текст повідомлення
		   <em>"Помилка значення - значення відсутнє в масиві"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep256
		   \brief Повідомлення для size_failure
		   \since v0.1.3.0 commit d66e53
		   \par Текст повідомлення
		   <em>"Помилка розміру - помилка зміни розміру; наприклад, це може
		   статися, коли розміри збігаються, коли розмір масиву змінюється, або
		   новий розмір більше/менше за межі розмірів"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep400
		   \brief Повідомлення для void_data
		   \since v0.1.3.0 commit d66e53
		   \par Текст повідомлення
		   <em>"Отримано порожню структуру даних"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep404
		   \brief Повідомлення для not_found
		   \since v0.1.3.0 commit d66e53
		   \par Текст повідомлення
		   <em>"Помилка пошуку - елемент не знайдено"</em>
		 */

		/*!
		   \class ALGOR::EXCEPTION_SET::memory_overflow
		   \brief Клас-виняток \a "memory_overflow"
		   \details Базовий виняток \a memory_overflow (переповнення пам'яті).
		   Використовує повідомлення EXCEPTION_SET::excep55 та має номер \a 55.
		   \since v0.1.1.0 commit bce6b6
		   \remark Де-які методи при киданні винятку \a 55 можуть давати пояснення.
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::memory_overflow::memory_overflow()
			   \brief Виняток memory_overflow
			   \details Конструктор об'єкту, що використовується, як виняток
			   memory_overflow. До каркасу передаються код виключення та деталі.
			   \since v0.1.1.0 commit bce6b6
			   \test
			   \snippet Algor_exception.cpp exception memory_overflow
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::memory_overflow::memory_overflow(const byte1_t *)
			   \brief Виняток memory_overflow з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   memory_overflow. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \test
			   \snippet Algor_exception.cpp exception memory_overflow explanation
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::division_by_zero
		   \brief Клас-виняток \a "division_by_zero"
		   \details Базовий виняток \a division_by_zero (ділення на нуль).
		   Використовує повідомлення EXCEPTION_SET::excep101 та має номер \a 101.
		   \since v0.1.2.0 commit d74cc1
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::division_by_zero::division_by_zero()
			   \brief Виняток division_by_zero
			   \details Конструктор об'єкту, що використовується, як виняток
			   division_by_zero. До каркасу передаються код виключення та деталі.
			   \since v0.1.2.0 commit d74cc1
			   \test
			   \snippet Algor_exception.cpp exception division_by_zero
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::division_by_zero::division_by_zero(const byte1_t *)
			   \brief Виняток division_by_zero з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   division_by_zero. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \test
			   \snippet Algor_exception.cpp exception division_by_zero explanation
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::position_failure
		   \brief Клас-виняток \a "position_failure"
		   \details Базовий виняток \a position_failure (збій положення).
		   Використовує повідомлення EXCEPTION_SET::excep254 та має номер \a 254.
		   \since v0.1.1.0 commit 8bbf75
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::position_failure::position_failure()
			   \brief Виняток position_failure
			   \details Конструктор об'єкту, що використовується, як виняток
			   position_failure. До каркасу передаються код виключення та деталі.
			   \since v0.1.1.0 commit 8bbf75
			   \test
			   \snippet Algor_exception.cpp exception position_failure
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::position_failure::position_failure(const byte1_t *)
			   \brief Виняток position_failure з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   position_failure. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \test
			   \snippet Algor_exception.cpp exception position_failure explanation
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::value_failure
		   \brief Клас-виняток \a "value_failure"
		   \details Базовий виняток \a value_failure (збій значення).
		   Використовує повідомлення EXCEPTION_SET::excep255 та має номер \a 255.
		   \since v0.1.1.0 commit 8bbf75
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::value_failure::value_failure()
			   \brief Виняток value_failure
			   \details Конструктор об'єкту, що використовується, як виняток
			   value_failure. До каркасу передаються код виключення та деталі.
			   \since v0.1.1.0 commit 8bbf75
			   \test
			   \snippet Algor_exception.cpp exception value_failure
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::value_failure::value_failure(const byte1_t *)
			   \brief Виняток value_failure з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   value_failure. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \test
			   \snippet Algor_exception.cpp exception value_failure explanation
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::size_failure
		   \brief Клас-виняток \a "size_failure"
		   \details Базовий виняток \a size_failure (збій розміру).
		   Використовує повідомлення EXCEPTION_SET::excep256 та має номер \a 256.
		   \since v0.1.3.0 commit 2c6408
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::size_failure::size_failure()
			   \brief Виняток size_failure
			   \details Конструктор об'єкту, що використовується, як виняток
			   size_failure. До каркасу передаються код виключення та деталі.
			   \since v0.1.3.0 commit 2c6408
			   \test
			   \snippet Algor_exception.cpp exception size_failure
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::size_failure::size_failure(const byte1_t *)
			   \brief Виняток size_failure з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   size_failure. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \test
			   \snippet Algor_exception.cpp exception size_failure explanation
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::void_data
		   \brief Клас-виняток \a "void_data"
		   \details Базовий виняток \a void_data (недійсні дані).
		   Використовує повідомлення EXCEPTION_SET::excep400 та має номер \a 400.
		   \since v0.1.1.0 commit c62e85
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::void_data::void_data()
			   \brief Виняток void_data
			   \details Конструктор об'єкту, що використовується, як виняток
			   void_data. До каркасу передаються код виключення та деталі.
			   \since v0.1.1.0 commit c62e85
			   \test
			   \snippet Algor_exception.cpp exception void_data
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::void_data::void_data(const byte1_t *)
			   \brief Виняток void_data з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   void_data. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \test
			   \snippet Algor_exception.cpp exception void_data explanation
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::not_found
		   \brief Клас-виняток \a "not_found"
		   \details Базовий виняток \a not_found (не знайдено).
		   Використовує повідомлення EXCEPTION_SET::excep404 та має номер \a 404.
		   \since v0.1.1.0 commit c62e85
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::not_found::not_found()
			   \brief Виняток not_found
			   \details Конструктор об'єкту, що використовується, як виняток
			   not_found. До каркасу передаються код виключення та деталі.
			   \since v0.1.1.0 commit c62e85
			   \test
			   \snippet Algor_exception.cpp exception not_found
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::not_found::not_found(const byte1_t *)
			   \brief Виняток not_found з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   not_found. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \test
			   \snippet Algor_exception.cpp exception not_found explanation
			 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                 ALGOR_RANDOM                                *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

	/*!
	  \namespace ALGOR::RANDOM
	  \brief Простір імен, що реалізовує ГПВЧ
	  \details Простір імен являє собою набір класів, які використовуються при
	  Генерації ПсевдоВипадкових Чисел (ГПВЧ). Класи є реалізаціями математичних
	  моделей. Зазвичай використовуються при генерації структур даних, таких як
	  масиви тощо.
	  \since v0.1.3.0 commit d66e53
	 */

		/*!
		   \class ALGOR::RANDOM::LCM
		   \brief ГПВЧ Лінійний Конґруентний Метод
		   \details Один з найпростіших ГПВЧ. Працює за принципом розрахунку
		   наступного числа. Представляється формулою
		   \f[x_n = (a * x_{n-1} + c)mod(m)\f], де \f$a, c, m\f$ - константні
		   коефіціенти.
		   \since v0.1.3.0 commit ca0704
		   \remark LCM = LinearCongruentMethod
		   \par Ресурси
		   Source: https://en.wikipedia.org/wiki/Linear_congruential_generator\n
		   Paragraph: Parameters in common use\n
		   Table row: MMIX by Donald Knuth\n
		   \test
		   \snippet Algor_random.cpp LCM class
		 */

			/*!
			   \fn ALGOR::RANDOM::LCM::LCM(memcell_t)
			   \brief Конструктор класу, що приймає сі́м'я
			   \details Конструктор, що приймає сі́м'я ГПВЧ, що є першим числом
			   послідовності, що генерується (\f$x_0\f$). Являє собою аналог
			   стандартної функції \a srand().
			   \param[in] seed
			   \since v0.1.3.0 commit ca0704
			   \test
			   \snippet Algor_random.cpp LCM srand
			 */

			/*!
			   \fn ALGOR::RANDOM::LCM::rand()
			   \brief Метод генерації псевдовипадкового числа
			   \details Алгоритм, що генерує (\a розраховує) наступне число
			   послідовності.
			   \since v0.1.3.0 commit ca0704
			   \retval seed - наступне число послідновності \f$x_n\f$
			   \test
			   \snippet Algor_random.cpp LCM rand
			 */

			/*!
			   \var ALGOR::RANDOM::LCM::a
			   \brief Перше константне число \f$a\f$
			   \details Константа \f$a\f$ = 6'364'136'223'846'793'005.
			   \since v0.1.3.0 commit ca0704
			 */

			/*!
			   \var ALGOR::RANDOM::LCM::c
			   \brief Перше константне число \f$c\f$
			   \details Константа \f$c\f$ = 1'442'695'040'888'963'407.
			   \since v0.1.3.0 commit ca0704
			 */

			/*!
			   \var ALGOR::RANDOM::LCM::m
			   \brief Перше константне число \f$m\f$
			   \details Константа \f$m\f$ = 18'446'744'073'709'551'615.
			   \since v0.1.3.0 commit ca0704
			 */

			/*!
			   \var ALGOR::RANDOM::LCM::seed
			   \brief Сі́м'я послідовності \f$x_0\f$
			   \details Число, що задає початок послідовності, що генерується.
			   \since v0.1.3.0 commit ca0704
			 */

		/*!
		   \class ALGOR::RANDOM::RC4
		   \brief Простий криптостійкий генератор
		   \details RC4 — потоковий шифр, розроблений Роном Рівестом
		   (анг. Ron Rivest) у 1987 році.
		   \since v0.1.0.0 commit 88415c
		   \note Може генерувати значення лише у діапазоні 0-255 (1 байт).
		   \deprecated На даному етапі розробка даного ГВЧ заморожена. Алгоритм
		   застарів. З часом можливе його повне видалення, чи повна модернізація,
		   чому не радиться його використовувати.
		   \par Ресурси
		   Source: https://www.youtube.com/watch?v=PQlZI-QoM2A\n
		   \test
		   \snippet Algor_random.cpp RC4 class
		*/

			/*!
			   \fn ALGOR::RANDOM::RC4::crypto_srand(const byte1_t *, byte4_t)
			   \brief Встановлює ключ генерації
			   \details Приймає ключ і розраховує з нього ключ генерації
			   \param[in] key Ключ, що встановлюється
			   \param[in] ksize Розмір ключа
			   \since v0.1.0.0 commit 88415c
			   \test
			   \snippet Algor_random.cpp RC4 srand
			 */

			/*!
			   \fn ALGOR::RANDOM::RC4::crypto_rand(byte1_t *, byte4_t)
			   \brief Генерує значення
			   \details Генерує масив вихідних зашифрованих значень, які можна
			   використовувати, як згенеровані ГВЧ.
			   \param[out] output Генерує масив вихідних елементів
			   \param size Розмір масиву вихідних елементів
			   \since v0.1.0.0 commit 88415c
			   \test
			   \snippet Algor_random.cpp RC4 rand
			 */

			/*!
			   \var ALGOR::RANDOM::RC4::Sbox
			   \brief Ключ генерації
			   \since v0.1.0.0 commit 88415c
			 */

		/*!
		   \class ALGOR::RANDOM::MersenneTwister
		   \brief Складний ГПВЧ, що базується на властивостях простих чисел Мерсенна
		   \details Вихор Мерсенна — ГПВЧ, розроблений у 1997 році японськими
		   вченими Макото Мацумото та Такудзі Нісімурою. Вихор Мерсенна ґрунтується
		   на властивостях простих чисел Мерсенна та забезпечує швидке генерування
		   високоякісних за критерієм випадковості псевдовипадкових чисел.
		   \since v0.1.0.0 commit 88415c
		   \deprecated На даному етапі розробка даного ГВЧ заморожена. Нехай
		   він і краще за Лінійні ГПВЧ, його ще не доведено до відлагодженого стану.
		   Його ще й досі складно використовувати. У майбутньому можлива повна
		   зміна сигнатур методів у класі. Чи його повне видалення.
		   \par Ресурси
		   Source: https://www.agner.org/random/\n
		   \test
		   \snippet Algor_random.cpp MT class
		 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::MersenneTwister(byte4_t)
			   \brief Конструктор класу ГПВЧ Вихор Марсенна (встановлює сі́м'я)
			   \details Встановлює сі́м'я та проводить ініціалізацію послідовності,
			   що буде генеруватися.
			   \param[in] seed Сі́м'я генерації
			   \since v0.1.0.0 commit 88415c
			   \test
			   \snippet Algor_random.cpp MT srand
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::RandomInit(byte4_t)
			   \brief Ініціалізація ГПВЧ
			   \details Використовується при перевстановленні семені ГПВЧ.
			   \param[in] seed Сі́м'я генерації
			   \since v0.1.0.0 commit 88415c
			   \test
			   \snippet Algor_random.cpp MT reinit
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::rand()
			   \brief Метод генеації даних на усьому можливому діапазоні
			   \details Генерує числа на увесь можливий діапазон змінної. Цей метод
			   спеціально було створено під сумісність з функцією тестування ГПВЧ.
			   \since v0.1.3.0 commit ca0704
			   \warning Цей метод було написано лише для функції тестування ГПВЧ. Не
			   використовуйте його, якщо у вас є обмеження на число, що має бути
			   згенероване. Для цього використовуйте метод
			   MersenneTwister::IRandom, що спеціально для цього й створювався.
			   \warning А також, якщо Вам потрібно згенерувати число на усьому
			   діапазоні, то краще використати MersenneTwister::BRandom, щоб уникнути
			   додаткових розрахунків.
			   \deprecated Буде видалено після завершення тестування ГПВЧ
			   \return згенероване число
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::IRandom(byte4_t, byte4_t)
			   \brief Метод генерація числа у заданому діапазоні
			   \details Генерує число у заданому діапазоні.
			   \param[in] min Мінімальне число діапазону
			   \param[in] max Максимальне число діапазону
			   \since v0.1.0.0 commit 88415c
			   \return згенероване число у заданому діапазоні
			   \test
			   \snippet Algor_random.cpp MT rand int
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::IRandomX(byte4_t, byte4_t)
			   \brief Більш точніший метод генерація числа у заданому діапазоні
			   \details Є аналогом методу MersenneTwister::IRandom, що генерує
			   число за складнішим алгоритмом, а саме число є більш точнішим.
			   \param[in] min Мінімальне число діапазону
			   \param[in] max Максимальне число діапазону
			   \since v0.1.0.0 commit 88415c
			   \return точне згенероване число у заданому діапазоні
			   \test
			   \snippet Algor_random.cpp MT rand int extend
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::Random()
			   \brief Метод генеріції числа з плаваючою комою
			   \details Генерує числа з плаваючою комою
			   \since v0.1.0.0 commit 88415c
			   \warning Цей метод генерує числа від 0 до 1, тобто всі
			   згенеровані числа будуть меншими від одиниці
			   \return число з плаваючою комою
			   \test
			   \snippet Algor_random.cpp MT rand double
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::BRandom()
			   \brief Метод генерації випадкових бітів
			   \details Генерує випадкові біти у змінній з чотирьох байт, що дозволяє
			   згенерувати 32-бітове число на всьому діапазоні.
			   \since v0.1.0.0 commit 88415c
			   \note Може слугувати аналогом методу MersenneTwister::rand, але той
			   метод є надстройкою над MersenneTwister::IRandom для функції тестування
			   ГПВЧ, що викликає додаткові розрахунки та витрати ресурсів. Якщо
			   потрібно відразу згенерувати якесь число на усьому діапазоні, то краще
			   обирати цей метод.
			   \return згенероване число на всьому діапазоні
			   \test
			   \snippet Algor_random.cpp MT rand bits
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::Init0(byte4_t)
			   \brief Базова процедура ініціалізації
			   \param[in] seed Сі́м'я генерації
			   \since v0.1.0.0 commit 88415c
			 */

			/*!
			   \var ALGOR::RANDOM::MersenneTwister::mersenne_twister
			   \brief Вектор стану
			   \since v0.1.0.0 commit 88415c
			 */

			/*!
			   \var ALGOR::RANDOM::MersenneTwister::mersenne_twister_index
			   \brief Індекс у векторі стану (MersenneTwister::mersenne_twister)
			   \since v0.1.0.0 commit 88415c
			 */

			/*!
			   \var ALGOR::RANDOM::MersenneTwister::LastInterval
			   \brief Довжина останнього інтервалу для MersenneTwister::IRandomX
			   \since v0.1.0.0 commit 88415c
			 */

			/*!
			   \var ALGOR::RANDOM::MersenneTwister::RejectionLimit
			   \brief Ліміт відхилень, який використовує MersenneTwister::IRandomX
			   \since v0.1.0.0 commit 88415c
			 */

		/*!
		   \fn ALGOR::RANDOM::test_random_on_Pearsons_coefficient(ubit32_t, ubit32_t)
		   \brief Функція тестування ГПВЧ на рівномірність
		   \details Тестує ГПВЧ на рівномірність генерації чисел, використовуючи
		   коефіціент узгодженості Пірсона.
		   \tparam Generator Клас алгоритму ГПВЧ, що потрібно протестувати.
		   \param[in] left_limit Мінімальне число діапазону генерації
		   при тестуванні
		   \param[in] right_limit Максимальне число діапазону генерації
		   при тестуванні
		   \since v0.1.3.0 commit ca0704
		   \warning ГВЧ RANDOM::RC4 поки не можна протестувати, так як його не
		   підготовлено до використання данною функцією тестування, та й сама
		   функція не компілюється під цей алгоритм.
		   \return коефіціент узгодженості Пірсона
		   \test
		   \snippet Algor_random.cpp random test
		   \remark Як можна побачити з прикладу, RANDOM::LCM генерує
		   числа більш рівномірно. Однак це не значить, що він є кращим... Як вже
		   було сказано, ГПВЧ Вихор Марсена є швидшим <del>(хоча й використовує
		   набагато більше операцій та розрахунків)</del> та якіснішим. А отримані
		   результати є лише випадковістю. Інколи краще генерує RANDOM::LCM, а
		   інколи RANDOM::MersenneTwister, через що можна зробити висновок, що вони
		   однаково якісно генерують числа <del>(чи може просто добре підібрані
		   коефіціенти для RANDOM::LCM)</del>. Для функції генерації
		   ALGOR::generate_struct структури масиву ALGOR::Array все ж таки було
		   обрано RANDOM::LCM, так як він набагато легший у реалізації та
		   розумінні, а працює так само якісно, як і RANDOM::MersenneTwister.
		 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                 ALGOR_ARRAY                                 *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

	/*!
	   \class ALGOR::ArrayProcessing
	   \brief Класс базових функцій для роботи з масивами
	   \details Клас із базовими функціями обробки масивів. Вони призначені, як
	   для зміни масиву, так і для визначення його певних характеристик. Функції
	   розраховані під використання стандартних С++ масивів, без поглиблення в
	   абстракції, типу використання структур чи класів (на те вони і є базовими).
	   \tparam type_array Тип елементів, які зберігає масив, який потрібно обробити
	   \since v0.1.2.0 commit 1981d6
	   \remark У вас можуть виникнути питання щодо версіонування. Тема роз'яснена
	   на наступній сторінці \ref ArrayBaseHistory.md
	   \image html ArrayProcessingFamilyTree.png
	   \image latex ArrayProcessingFamilyTree.png "My application" width=10cm
	   \note Не обов'язково створювати структуру і з неї передавати данні до функцій.
	   Вони навмисно були розроблені, щоб вони приймали не структуру, а саме сам
	   масив
	   \warning Клас компілюється лише наступних типів: ALGOR::byte8_t, ALGOR::ubit64_t,
	   ALGOR::fbit64_t, ALGOR::fbit128_t, ALGOR::asize_t. Отже, функції працюють
	   лише з тими масивами, тип яких є long long, unsigned long long, double, long
	   double, unsigned int!!!
	 */

		/*!
		   \fn ALGOR::ArrayProcessing::minimum(const type_array *, const asize_t &)
		   \brief Шукає мінімальний елемент у масиві методом перебору
		   \details Методом перебору по всьому масиву функція шукає та повертає
		   найменше значення у масиві.
		   \param[in] Array Масив, у якому потрібно знайти мінімальний елемент
		   \param[in] array_size Розмір цього масиву
		   \since v0.0.0.1
		   \sa ALGOR::ArrayProcessing::maximum(const type_array *, const asize_t &)
		   \sa ALGOR::ARRAYDATA::getMin()
		   \warning Функція працює не з усіма типами. Читай ALGOR::ArrayProcessing
		   \warning Ця функція не робить перевірку, чи є  масив відсортованим, а тому
		   не є ефективною. Краще перед виконанням цієї функції перевірити, чи є масив
		   відсортованим за допомогою функції ALGOR::ArrayProcessing::isOrderliness
		   \return значення найменшого елемента масиву
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing minimum
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::maximum(const type_array *, const asize_t &)
		   \brief Шукає максимальний елемент у масиві методом перебору
		   \details Методом перебору по всьому масиву функція шукає та повертає
		   найбільше значення у масиві.
		   \param[in] Array Масив, у якому потрібно знайти максимальний елемент
		   \param[in] array_size Розмір цього масиву
		   \since v0.0.0.1
		   \sa ALGOR::ArrayProcessing::minimum(const type_array *, const asize_t &)
		   \sa ALGOR::ARRAYDATA::getMax()
		   \warning Функція працює не з усіма типами. Читай ALGOR::ArrayProcessing
		   \warning Ця функція не робить перевірку, чи є  масив відсортованим, а тому
		   не є ефективною. Краще перед виконанням цієї функції перевірити, чи є масив
		   відсортованим за допомогою функції ALGOR::ArrayProcessing::isOrderliness
		   \return значення найбільшого елемента масиву
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing maximum
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::isOrderliness(const type_array *, const asize_t &)
		   \brief Функція, що перевіряє, чи впорядковано масив
		   \details Функція перевіряє, чи є масив впорядкованим у порядку збільшення.
		   Якщо у якийсь момент функція фіксує, що поточний елемент ітерації більше
		   наступного, вона відразу повертає значення \a false, інакше - всі елементи
		   йдуть у порядку збільшення і функція повертає \a true.
		   \param[in] Array Масив, що перевіряється на відсортованість
		   \param[in] array_size Розмір цього масиву
		   \since v0.1.2.0 commit 2fa93b
		   \warning Ця функція перевіряє впорядкованість тільки у напрямку збільшення.
		   Якщо необхдіно перевірити впорядкованість порядку зменшення: на вхід функції
		   треба передати обернений масив, а цим функціоналом володіє тільки
		   ALGOR::ARRAYDATA::reverse
		   \return логічне значення, чи є масив впорядкованим (так чи ні)
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing isOrderliness
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::distance(type_array *, type_array *)
		   \brief Повертає відстань між вказівниками на два елементи масиву
		   \details Розраховує різницю між двома вказівниками, яка (різниця) являє
		   собою відстань між цими самими двома вказівниками.
		   \param[in] first Вказівник на перший вказаний елемент масиву
		   \param[in] last Вказівник на другий вказаний елемент масиву
		   \since v0.1.2.1 commit ffc19f
		   \return різницю між адресами вказівників
		   \par Ресурси
		   Source: http://www.cplusplus.com/reference/iterator/distance/?kw=distance\n
		   \note Перевагами над стандартною функцією є те, що вона працює з об'єктами
		   класу ітератор (як можна побачити з прикладу на офіційній сторінці
		   документації), а данна функція працює просто із вказівниками, що
		   є легше та надійніше.
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing distance
		   \remark Дану функцію можна використовувати для знаходження розміру масива. Якщо
		   ви колись зберегли вказівник на останній елемент масиву, а сам розмір було
		   загублено <del>(я не знаю як ви могли це зробити)</del>, тоді ви можете
		   використати цей алгоритм, передавши вказівник на перший елемент масиву і
		   збережений вказівник на останній елемент масиву. Так як алгоритм
		   повертає різницю між адресами, то адреса цього самого останнього елемента
		   не буде порахована у розмір масиву, а тому розмір масиву становитиме на
		   одиницю більше повернутого значення:
		   \code{.cpp}
		   int size = 10; //The size that will be lost...
		   long long arr[size];
		   long long *last_element = &arr[9];
		   //...
		   //Lots and lots of code... You forgot where the size of the array is stored...
		   //...
		   //Use distance:
		   cout << "Size array is " << ArrayProcessing<long long>::distance(&arr[0], last_element) + 1 << "\n";
		   //or
		   cout << "Size array is " << ArrayProcessing<long long>::distance(&arr[0], last_element + 1) << "\n";
		   \endcode
		   Тут не важливо, чи збільшите ви підсумковий результат на одиницю, чи
		   посунете вказівник на одиницю. У другому випадку вказівник буде виходити
		   за межі масиву, але як вже було сказано, у результат нічого не потрапляє
		   ззовні зазначених адрес, а тому таким чином ви додасте іще один останній
		   елемент, який раніше не рахувався, і не більше того.
		   \remark Коли я тільки додав ці функції, я хотів перевести усі функції із
		   сигнатур {вказівник на масив; розмір масиву} на {перший елемент; останній
		   елемент} (як у ALGOR::ArrayProcessing::distance), але не задалося, так як передавати перший варіант легше. Самі
		   розсудіть:
		   \code{.cpp}
		   Array<long long> *arr = create_struct<long long>(10);
		   ArrayProcessing<long long>::minimum(arr->array, arr->array_size); //old variant {array pointer; array size}
		   \endcode
		   проти
		   \code{.cpp}
		   Array<long long> *arr = create_struct<long long>(10);
		   ArrayProcessing<long long>::minimum(&arr->array[0], &arr->array[arr->array_size - 1]); //new variant {first element; last element}
		   \endcode
		   Я б обрав {вказівник на масив; розмір масиву}.
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::lower_bound(type_array *, type_array *, const type_array &)
		   \brief Знаходить перше входження у заданому діапаоні заданого елемента
		   \details Функція не є рекурсивною. Але вона використовує вказівники, як
		   ітератори, розраховуючи їх аналогічно рекурсивному методу. Таким чином
		   функція є оптимізованою, завдяки переходу з рекурсії на ітерацію, а
		   великим плюсом є можливість задати певний діапазон, що можливо тільки з
		   двома функціями ALGOR::ArrayProcessing::lower_bound та
		   ALGOR::ArrayProcessing::upper_bound.
		   \param[in] first Вказівник на перший вказаний елемент масиву, що задає
		   початок діапазону масиву, де треба знайти заданий елемент
		   \param[in] last Вказівник на другий вказаний елемент масиву, що задає
		   кінець діапазону масиву, де треба знайти заданий елемент
		   \param[in] value Заданий елемент, який потрібно знайти
		   \since v0.1.2.1 commit ffc19f
		   \return вказівник на перше входження заданого елемента у заданому діапазоні
		   \warning Функція повертає лише вказівник на елемент, а не його значення.
		   \par Ресурси
		   Source: http://www.cplusplus.com/reference/algorithm/lower_bound/\n
		   \note Перевагами над стандартною функцією є те, що вона працює з об'єктами
		   класу ітератор (як можна побачити з прикладу на офіційній сторінці
		   документації), а данна функція працює просто із вказівниками, що
		   є легше та надійніше.
		   \warning Функція працює ітераційно аж до останнього елементу і повертає
		   вказівник саме на нього, не перевіряючи чи є це той самий потрібний елемент.
		   Але таке відбувається тільки з тими масивами, у яких взагалі нема заданого
		   елемента. Тому ви власноруч маєте перевіряти, чи є там взагалі потрібний
		   елемент.
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing lower_bound
		   \remark Дану функцію разом із ALGOR::ArrayProcessing::distance можна
		   використати для реалізації бінарного пошуку:
		   ALGOR::ArrayProcessing::lower_bound повертає вказівник на знайдений
		   елемент, а ALGOR::ArrayProcessing::distance розраховує відстань від
		   початку масиву, що і буде відображати положення у масиві (його номер).
		   Саме такий метод використиовується у ALGOR::ARRAYDATA::binary_getPosition.
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::upper_bound(type_array *, type_array *, const type_array &)
		   \brief Знаходить перше входження у заданому діапазоні елемента, що є
		   наступним після заданого
		   \details Аналогічно ALGOR::ArrayProcessing::lower_bound, данна функція
		   повертає вказівник на перше входження наступного елемента, після заданого.
		   \param[in] first Вказівник на перший вказаний елемент масиву, що задає
		   початок діапазону масиву, де треба знайти заданий елемент
		   \param[in] last Вказівник на другий вказаний елемент масиву, що задає
		   кінець діапазону масиву, де треба знайти заданий елемент
		   \param[in] value Заданий елемент, після якого потрібно повернути вказівник
		   \since v0.1.2.1 commit d94012
		   \return вказівник на перше входження наступного елемента після заданого
		   у заданому діапазоні
		   \note У цілому, використання функції подібне до
		   ALGOR::ArrayProcessing::lower_bound.
		   \par Ресурси
		   Source: http://www.cplusplus.com/reference/algorithm/upper_bound/\n
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing upper_bound
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::addElement(type_array *&, asize_t &, const type_array &, const asize_t)
		   \brief Додає певне значення до масиву у вказаній позиції
		   \details Функція додає задане значеннян у заданий масив із заданим
		   розміром на задану позицію. Функція працює на місці.
		   \remark Якщо задати і в якості розміру, і в якості позиції розмір
		   масиву, то елемент буде додано у кінець масиву, так як функція збільшує
		   розмір масиву перед тим, як почати додавати елемент, а тому на цей момент
		   старий розмір масиву буде лише вказувати на позицію нового останнього
		   елемента. Саме тому цю функцію легше всього використовувати замість
		   push_back().
		   \param[in, out] Array Масив, до якого додається елемент
		   \param[in] array_size Розмір цього масиву
		   \param[in] value Елемент, який потрібно додати до масиву
		   \param[in] position Позиція, у якій буде додано елемент
		   \since v0.0.1.0 commit e37003
		   \exception EXCEPTION_SET::memory_overflow
		   \sa ALGOR::ArrayProcessing::subtractElement(type_array *&, asize_t &, const asize_t)
		   \sa ALGOR::ArrayProcessing::subtractValue(type_array *&, asize_t &, const type_array &)
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing addElement
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::subtractElement(type_array *&, asize_t &, const asize_t)
		   \brief Видаляє елемент по вказаній позиції у масиві
		   \details Видаляє елемент по вказаній позиції з масиву. Схожий на
		   ALGOR::ArrayProcessing::addElement.
		   \param[in, out] Array Масив, у якому буде видалено елемент по позиції
		   \param[in] array_size Розмір цього масиву
		   \param[in] position Позиція, з якої буде видалено елемент
		   \since v0.1.0.0 commit 37cab7
		   \warning Не забувайте, що нумерація починається з 0!
		   \exception EXCEPTION_SET::void_data
		   \exception EXCEPTION_SET::position_failure
		   \sa ALGOR::ArrayProcessing::addElement(type_array *&, asize_t &, const type_array &, const asize_t)
		   \sa ALGOR::ArrayProcessing::subtractValue(type_array *&, asize_t &, const type_array &)
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing subtractElement
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::subtractValue(type_array *&, asize_t &, const type_array &)
		   \brief Видаляє зазначений елемент з усіх позицій у масиві
		   \details На відміну від ALGOR::ArrayProcessing::subtractElement, що
		   видаляє лише один елемент у вказаній позиції, ця функція приймає не
		   позицію, а саме значення, що дозволяє його видалити з усіх позицій у
		   всьому масиві.
		   \param[in, out] Array Масив, у якому буде видалено всі елементи, що
		   відповідають заданому значенню
		   \param[in] array_size Розмір цього масиву
		   \param[in] value Значення, яке потрібно видалити з усього масиву
		   \since v0.1.0.0 commit 37cab7
		   \exception EXCEPTION_SET::void_data
		   \exception EXCEPTION_SET::value_failure
		   \sa ALGOR::ArrayProcessing::addElement(type_array *&, asize_t &, const type_array &, const asize_t)
		   \sa ALGOR::ArrayProcessing::subtractElement(type_array *&, asize_t &, const asize_t)
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing subtractValue
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::copy(type_array *, const type_array *, const asize_t &, asize_t, asize_t)
		   \brief Копіює масив
		   \details Функція копіювання масиву. Але це не проста функція, а
		   багатофункціональна. Окрім того, що треба задати масив, з якого
		   копіюються данні, масив, до якого копіюються данні та обсяг данних,
		   які потрібно скопіювати, можна ще задати позиції у цих масивах, а
		   саме: з якої позиції почати копіювати данні та з якої позиції почати
		   записувати данні до масива. \n Для прикладу, Ви можете задати функції,
		   щоб вона скопіювала з 5 по 10 елемент зі старого масиву (усього п'ять
		   з п'ятої позиції) до нового масиву, при чому почати зберігатися
		   елементи повинні у новому масиві з п'ятої позиції (див. приклад).
		   \param[in, out] new_array Масив, у який копіюються дані
		   \param[in] old_array Масив, з якого потрібно скопіювати дані
		   \param[in] size_of_copied Параметр, який вказує, скільки елементів
		   потірбно скопіювати
		   \param[in] position_in_new_array Позиція, з якої починається запис в
		   масив, до якого копіюються дані
		   \param[in] position_in_old_array Позиція, з якої починається читання
		   у масиві, з якого копіюються дані
		   \since v0.0.0.3 commit 1a11a0
		   \warning До функції не передаються розміри масивів, через що функція не
		   може перевірити, чи задаєте ви їй правильні данні. Через це програміст
		   має бути дуже обережним з цією функцією
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing copy
		 */

	/*!
	   \struct ALGOR::Array
	   \brief Структура, що імітує масив
	   \details Призначений для зберігання вказівника на динамічний масив та його
	   розмір
	   \tparam type_array Тип елементів, що зберігаються в масиві
	   \since v0.0.1.0 commit 979bf4
	   \warning Структуру можна створити будь-якого типу, але функції та класи
	   підтримують тільки 5 типів: \a byte8_t, \a ubit64_t, \a fbit64_t,
	   \a fbit128_t та \a asize_t. Тому будь-які інші типи можна використовувати
	   тільки тоді, коли дана структура не буде взаємоді'яти з функіоналом
	   бібліотеки, інакше ви зіштовхнетесь з помилкою <em>"undefined reference
	   to"</em>.
	   \test
	   \snippet Algor_core.cpp array struct
	 */

		/*!
		   \var ALGOR::Array::array
		   \brief Вказівник на масив
		   \since v0.0.1.0 commit 979bf4
		 */

		/*!
		   \var ALGOR::Array::array_size
		   \brief Розмір масиву
		   \since v0.0.1.0 commit 979bf4
		 */

	/*!
	   \fn ALGOR::create_struct(const asize_t &, bool)
	   \brief Створює структуру з покажчиком на масив
	   \details Зберігає розмір масиву, виділяє пам'ять під цей самий масив та повертає
	   вказівник на структуру масиву.
	   \tparam type_array Тип елементів, що будуть зберігатися у масиві
	   \param[in] SIZE Розмір створюваного масиву
	   \param[in] mem_allocation Логічний флаг, чи потрібно виділяти пам'ять під масив
	   \retval Array<type_array>* вказівник на створену структуру
	   \since v0.1.0.0 commit 85698d
	   \remark Якщо ви вже виділили пам'ять під масив, то структурі не потрібно повторно
	   виділяти пам'ять. Структура лише зберігає розмір масиву та сам вказівник на цей
	   масив. Тому у цьому випадку флагу \a mem_allocation потрібно передати \a false і
	   після цього зберегти вказівник на масив у структурі. У інших випадках флаг
	   \a mem_allocation краще не змінювати.
	   \test
	   \snippet Algor_core.cpp create_struct
	 */

	/*!
	   \fn ALGOR::generate_struct(Array<type_array> *&, const sbit64_t &, const sbit64_t &, const ubit64_t, const ubit32_t)
	   \brief Генерує випадкові значення у структурі масиву
	   \details Генерує у структурі масиву значення із заданого діапазону. Якщо
	   задати \a denominator, то можна отримати кратні, чи дрібні значення данних.
	   \throw ALGOR::EXCEPTION_SET::division_by_zero
	   \tparam type_array Вказує якого типу будуть генеруватися числа у структурі
	   масиву
	   \param[in, out] Array Структура масиву, у якій потрібно згенерувати данні
	   \param[in] min_limit Мінімально можливе згенероване значення
	   \param[in] max_limit Максимально можливе згенероване значення
	   \param[in] seed Сі́м'я генератору
	   \param[in] denominator Дільник для генерації \a float данних
	   \since v0.1.3.0 commit ca0704
	   \note На випадок, якщо не працює ALGOR::getMemoryCell, можна власноруч
	   задати сі́м'я генерації.
	   \test
	   \snippet Algor_core.cpp generate_struct
	 */

	/*!
	   \fn ALGOR::remove_struct(Array<type_array> *&)
	   \brief remove_struct
	   \details Звільняє пам'ять від масиву, що зберігається у структурі й звільняє
	   з пам'яті саму структуру
	   \tparam type_array Тип елементів, що зберігаються у масиві
	   \param[in, out] Array Масив, який потрібно видалити
	   \result Вказівник на структуру після виклику цієї функції буде вказувати на
	   \a nullptr.
	   \since v0.0.0.1
	   \test
	   \snippet Algor_core.cpp remove_struct
	 */

	/*!
	   \class ALGOR::ArrayBase
	   \brief Базовий клас, від якого успадковуються інші класи, пов'язані з роботою
	   з масивами
	   \warning Об'єкт цього класу не можна створити!
	   \details Базовий клас, призаначений для використання класами-нащадками, що
	   використовуються при роботі з масивами. Цей клас містить готові конструктори та
	   готове поле для зберігання вказівника на структуру масиву. Використовується,
	   щоб не писати повторно у кожному класі одну й ту ж реалізацію конструкторів
	   та не прописувати заново поле вказівника. А отже буде менше коду.
	   \tparam type_array Тип елементів, що зберігаються у структурі об'єкту масиву
	   \since v0.1.0.0 commit 6efeb8
	   \par Історія
	   На відміну від інших класів, у класу ALGOR::ArrayBase найрізноманітніша та
	   цікава історія. Його еволюція відбувалась 4 комміти поспіль і від першої
	   реалізації він ніс трохи інший сенс свого існування...\n
	   Більш детально читайте на сторінці \ref ArrayBaseHistory.md
	   \image html ArrayProcessingFamilyTree.png
	   \image latex ArrayProcessingFamilyTree.png "My application" width=10cm
	 */

		/*!
		   \fn ALGOR::ArrayBase::ArrayBase(Array<type_array> *&)
		   \brief Конструктор базового класу, що приймає СТРУКТУРУ та зберігає її
		   до поля
		   \details Конструктор, що приймає структуру для збереження вказівника на неї.
		   Спочатку конструктор перевіряє, чи не є масив пустим. Якщо масив
		   пустий - кидається виключення. Інакше - зберігається вказівник.
		   \warning При такому створенні об'єкта класу обидві сутності будуть
		   зберігати вказівники на одну й ту саму структуру, а тому зміна масиву
		   через одну із сутностей буде впливати на обидві сутності!!!
		   \param[in] Array Покажчик на структуру масиву
		   \since v0.1.0.0 commit 6efeb8
		   \exception EXCEPTION_SET::void_data
		 */

		/*!
		   \fn ALGOR::ArrayBase::ArrayBase(const asize_t &)
		   \brief Конструктор базового класу, що приймає РОЗМІР та виділяє пам'ять
		   \details Конструктор, що виділяє пам'ять під абсолютно новий чистий масив.
		   \warning Передача нульового розміру сприймається за збереження пустого
		   масиву, що заборонено правилами безпеки бібліотеки ALGOR:
		   > Об'єкти класів масивів не мають зберігати пусті масиви, щоб уникнути
		   > непередбачуваної поведінки та запобігти вилітам програм.
		   \param[in] SIZE Розмір створюваного масиву
		   \since v0.1.0.0 commit 1d50a2
		   \exception EXCEPTION_SET::void_data
		 */

		/*!
		   \fn ALGOR::ArrayBase::ArrayBase()
		   \brief Пустий конструктор
		   \details Просто пустий конструктор, який нічого не виконує.
		   \since v0.1.0.0 commit 48aa64, dd5d42+
		   \deprecated Раніше він використовувася у тих випадках, коли виділяти
		   пам'ять під структуру не потрібно (так як вказівнику не було присвоєно
		   nullptr і це робив даний конструктор), але з часом вказівнику було
		   присвоєно nullptr і надібність у цьому відпала... А цей метод залишено
		   на випадок, якщо колись з'явиться необхідність написати якусь
		   реалізацію у конструкторі базового класу.
		 */

		/*!
		   \fn ALGOR::ArrayBase::verification(Array<type_array> *)
		   \brief Метод перевірки масиву
		   \details Метод, що перевіряє масив на пустотність. Якщо розмір масиву
		   дорівнює нулю, можна вважати, що масив пустий, так як вказівник на сам
		   масив вказує на nullptr. Зазвичай метод використовується для перевірок
		   структур перед тим, як зберегти вказівник на структуру до об'єкту класа,
		   щоб до класу не міг потрапити пустий масив.
		   \param[in] Array Масив, що перевіряється
		   \since v0.1.1.0 commit 8bbf75
		   \exception EXCEPTION_SET::void_data
		   \par Історія
		   Історія цього методу не така цікава, як у класа ArrayBase, але його життя
		   добре потріпало.\n
		   Спочатку це мала бути прихована функція, що видна лише усередині
		   бібліотеки. Для цього я всього лиш написав її у файлі реалізацій без її
		   оголошення у хідері. Такою вона залишалась довгий час... Але прийшов
		   час зайнятись безпекою бібліотеки перед релізом v1.0.0.0, так як з
		   останньої безпекозації (коли й було додано цю функцію) багато чого
		   змінилось. У релізі v0.1.3.0 проводилась реформа ARRAYDATA, коли тимчасово
		   став публічним ARRAYDATA::remove. Спочатку цю функцію було перейменовано, а
		   потім і взагалі тимчасово видалено. Чому тимчасово? Тому що коли я удруге
		   прийшов до концепції, що об'єкт класу масиву не має зберігати пустий
		   масив, я назад приховав ARRAYDATA::remove, довів рівень безпеки
		   до потрібного рівня і повернув цю функцію, як метод базового класу, який
		   можуть використовувати успадковані класи при збережені до себе масивів.\n
		   Короче, судьби ArrayBase та verification перетнулися. Дивлячись на
		   історію ArrayBase, розумієш, що це вийшло не випадково...
		   \note Можливо у майбутньому буде проводитись більше перевірок, якщо
		   кількість характеристик зросте.
		 */

		/*!
		   \var ALGOR::ArrayBase::ARRAY
		   \brief Вказівник на структуру, що зберігає масив
		   \since v0.1.0.0 commit 6efeb8
		 */

	/*!
	   \class ALGOR::ARRAYDATA
	   \brief Клас з потужним функціоналом обробки масивів
	   \details Це головний клас для роботи з масивами, завданнями якого є зберігання
	   вказівника на структуру масиву та його обробка. Клас має потужний функціонал:
	   клонування, пошук, перевизначення, характеризація тощо. А достатня кількість
	   перевантажених операторів багатократно полегшує роботу з даними.
	   \tparam type_array Тип елементів, що зберігаються у структурі об'єкту масиву
	   \since v0.0.0.1
	   \remark У вас можуть виникнути питання щодо версіонування. Тема роз'яснена
	   на наступній сторінці \ref ArrayBaseHistory.md
	   \image html ArrayProcessingFamilyTree.png
	   \image latex ArrayProcessingFamilyTree.png "My application" width=10cm
	 */

		/*!
		   \fn ALGOR::ARRAYDATA::ARRAYDATA(Array<type_array> *&)
		   \brief Конструктор, що приймає СТРУКТУРУ та зберігає її до поля
		   \details Читай детальніше ALGOR::ArrayBase::ArrayBase(Array<type_array> *&)
		   \param[in] Array Покажчик на структуру масиву
		   \since v0.1.0.0 commit 48aa64
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA constructor struct
		   \sa ALGOR::ArrayBase::ArrayBase(Array<type_array> *&)
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::ARRAYDATA(const asize_t &)
		   \brief Конструктор, що приймає РОЗМІР та виділяє пам'ять
		   \details Читай детальніше ALGOR::ArrayBase::ArrayBase(const asize_t &)
		   \param[in] SIZE Розмір створюваного масиву
		   \since v0.1.0.0 commit 1d50a2
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA constructor size
		   \sa ALGOR::ArrayBase::ArrayBase(const asize_t &)
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::~ARRAYDATA()
		   \brief Деструктор класу
		   \details Звільняє пам'ять від масиву, що зберігається у об'єкті.
		   Викликається при завершенні програми
		   \warning Якщо у програмі реалізовані структури, що зберігають вказівники
		   на ті масиви, що зберігаються у об'єктах - тоді звільняти пам'ять від
		   масивів у структурах не треба, так як це зробить деструктор класу при
		   завершенні програми. Видаляйте тільки ті структури, які не зберігаються
		   у об'єктах!
		   \since v0.1.1.0 commit bce6b6
		 */

		/*!
		   \enum ALGOR::ARRAYDATA::ArrayType
		   \brief Набір типів масиву
		   \details Перелік типів масиву. Використовується тільки методом
		   ALGOR::ARRAYDATA::searcherOccurrencesOfSubstring для правильного
		   виконання алгоритму.
		   \since v0.1.0.0 commit 85698d
		 */

			/*!
			   \var ALGOR::ARRAYDATA::ArrayType::NUMBER
			   \brief Вказує, що масив зберігає числа
			   \details Грубо кажучи, значення вказує алгоритму, що він працює з
			   масивом чисел. Насправді алгоритм використовує значення типу
			   масиву з переліку у своїх перевірках. Це потрібно для правильної
			   роботи алгоритму, оскільки з числовими та строковими данними він
			   працює по різному.
			   \since v0.1.0.0 commit 85698d
			 */

			/*!
			   \var ALGOR::ARRAYDATA::ArrayType::STRING
			   \brief Вказує, що масив зберігає строки
			   \details Грубо кажучи, значення вказує алгоритму, що він працює з
			   масивом-строкою. Насправді алгоритм використовує значення типу
			   масиву з переліку у своїх перевірках. Це потрібно для правильної
			   роботи алгоритму, оскільки зі строковими та числовими данними він
			   працює по різному.
			   \since v0.1.0.0 commit 85698d
			 */

		/*!
		   \struct ALGOR::ARRAYDATA::mode
		   \brief Структура моди масиву
		   \details Розширена структура масиву. По суті це теж є масив. Масив
		   чисел, що зберігає всі числа, що найчастіше зустрічаються у
		   головному масиві. Але як дізнатись, з якою саме частотою? Для цього
		   і було розширено стандартну структуру ALGOR::Array полем для
		   зберігання цієї частоти. З цієї структури можна дізнатись, які
		   числа можна найчастіше зустріти (ALGOR::ARRAYDATA::mode::array),
		   скільки їх (ALGOR::ARRAYDATA::mode::array_size) та з якою частотою
		   вони зустрічаються (ALGOR::ARRAYDATA::mode::highest_frequency).
		   \warning На відміну від структури ALGOR::Array, для структури
		   ALGOR::ARRAYDATA::mode не реалізовано функціонал для звільнення
		   пам'яті після використання данних, тому програмісту самому потрібно
		   звільняти пам'ять.
		   \since v0.1.3.0 commit 391fff
		   \note Приклад використовується такий самий, як і для
		   ALGOR::ARRAYDATA::moda.
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA moda
		 */

			/*!
			   \var ALGOR::ARRAYDATA::mode::highest_frequency
			   \brief Частота моди
			   \since v0.1.3.0 commit 391fff
			 */

		/*!
		   \fn ALGOR::ARRAYDATA::generatedData(const sbit64_t &, const sbit64_t &, const ubit64_t, const ubit32_t)
		   \brief Метод, який заповнює весь масив випадковими значеннями
		   \details
		   \throw ALGOR::EXCEPTION_SET::division_by_zero
		   \param[in] min_limit Мінімальне значення, яке можна згенерувати
		   \param[in] max_limit Максимальне значення, яке можна згенерувати
		   \param[in] seed Сі́м'я генератору
		   \param[in] denominator Дільник для генерації \a float данних
		   \since v0.0.0.1
		   \remark У вас можуть виникнути питання щодо версіонування. Цей метод був
		   присутній з самого початку, але у версії v0.1.3.0 commit ca0704 я
		   вирішив виокремити алгоритм генерації чисел (точніше сказати, алгоритм
		   обробки згенерованих чисел) до функції ALGOR::generate_struct. Тоді
		   реалізація була перенесена з цього методу, а тут залишився лише
		   виклик нової функції. І якщо не дивитись на реалізації, то, по суті,
		   це і є перший метод.
		   \note На випадок, якщо не працює ALGOR::getMemoryCell, можна власноруч
		   задати сі́м'я генерації.
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA generatedData
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::setNewData(Array<type_array> *&)
		   \brief Метод, який замінює попередній масив на новий, звільняючи пам’ять
		   від попереднього
		   \details Видаляє з пам'яті старий масив та зберігає вказівник на інший
		   масив, що вже існує.
		   \throw ALGOR::EXCEPTION_SET::void_data
		   \remark Звернутися до старого масиву буде <b>НЕможливо</b>; зміни
		   у поточному об'єкті <b>будуть</b> відображатися на оригінальному об'єкті.
		   \param[in] Array Масив, який замінить попередній в об’єкті
		   \since v0.1.0.0 commit 1f2a4f
		   \warning Структура масиву, що зберігається у поточному об'єкті класу
		   за вказівником, буде видалена, тому якщо потрібно зберегти структуру
		   масиву, краще використати ALGOR::ARRAYDATA::setData. Якщо зміни у
		   поточному об'єкті не мають впливати на оригінальні данні, слід
		   використати ALGOR::ARRAYDATA::cloneNewData. Якщо і потрібно зберегти
		   масив, і дані не мають змінюватись у оригінальному об'єкті, потрібно
		   використати ALGOR::ARRAYDATA::cloneData.
		   \sa ALGOR::ARRAYDATA::setData(Array<type_array> *&)
		   \sa ALGOR::ARRAYDATA::cloneNewData(Array<type_array> *&)
		   \sa ALGOR::ARRAYDATA::cloneData(Array<type_array> *&)
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA setNewData
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::setData(Array<type_array> *&)
		   \brief Метод, який замінює попередній масив на новий без звільнення
		   пам’яті від попереднього
		   \details Зберігає вказівник на інший масив, що вже існує, без видалення
		   з пам'ятті старого масиву.
		   \throw ALGOR::EXCEPTION_SET::void_data
		   \remark Старий масив може бути збережений до іншого об'єкту чи
		   структури, тому звернутися до нього <b>можливо</b>; зміни у поточному
		   об'єкті <b>будуть</b> відображатися на оригінальному об'єкті.
		   \param[in] Array Масив, який замінить попередній в об’єкті
		   \since v0.1.0.0 commit 1f2a4f
		   \note Якщо зберігати старий масив не потрібно, тому краще використати
		   ALGOR::ARRAYDATA::setNewData, або потрібно, щоб зміни у поточному
		   об'єкті не впливали на оригінальний (без того самого збереження
		   старого масиву), то можна використати ALGOR::ARRAYDATA::cloneNewData.
		   \warning Аналогічно ALGOR::ARRAYDATA::setNewData,
		   ALGOR::ARRAYDATA::setData зберігає лише вказівник, тому якщо потрібно
		   зберегти данні так, щоб зміни у одному об'єкті не впливали на інший, треба
		   використовувати метод ALGOR::ARRAYDATA::cloneData.
		   \sa ALGOR::ARRAYDATA::setNewData(Array<type_array> *&)
		   \sa ALGOR::ARRAYDATA::cloneNewData(Array<type_array> *&)
		   \sa ALGOR::ARRAYDATA::cloneData(Array<type_array> *&)
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA setData
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::cloneNewData(Array<type_array> *&)
		   \brief Метод, який замінює старий масив шляхом копіювання існуючого з
		   видаленням старих денних
		   \details Звільняє пам'ять від старого масиву, виділяє пам'ять під новий масив
		   та повністю копіює данні із вказаного масиву. Таким чином зміни у одному
		   масиві не будуть відображатися на оригінальному.
		   \throw ALGOR::EXCEPTION_SET::void_data
		   \remark Звернутися до старого масиву буде <b>НЕможливо</b>; зміни
		   у поточному об'єкті <b>НЕ будуть</b> відображатися на оригінальному об'єкті.
		   \param[in] CloningArray Масив, який потрібно клонувати в об’єкт
		   \since v0.1.0.0 commit dd5d42
		   \note Якщо допускається, що зміни можуть впливати на обидва об'єкти, краще
		   використати ALGOR::ARRAYDATA::setNewData, а якщо ще й треба зберегти
		   старий масив, то краще використати ALGOR::ARRAYDATA::setData.
		   \warning Якщо потрібно зберегти старий масив, то краще використати
		   ALGOR::ARRAYDATA::cloneData.
		   \sa ALGOR::ARRAYDATA::setNewData(Array<type_array> *&)
		   \sa ALGOR::ARRAYDATA::setData(Array<type_array> *&)
		   \sa ALGOR::ARRAYDATA::cloneData(Array<type_array> *&)
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA cloneNewData
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::cloneData(Array<type_array> *&)
		   \brief Метод, який замінює старий масив шляхом копіювання існуючого без
		   видалення старих денних
		   \details Без звільнення пам'яті від старого масиву виділяє пам'ять під новий
		   масив та повністю копіює данні із вказаного масиву. Таким чином зберігається
		   і старий масив у іншому об'єкті чи структурі, а зміни на скопійованому масиві
		   не будуть відображатися на оригінальному.
		   \throw ALGOR::EXCEPTION_SET::void_data
		   \remark Старий масив може бути збережений до іншого об'єкту чи
		   структури, тому звернутися до нього <b>можливо</b>; зміни у поточному
		   об'єкті <b>НЕ будуть</b> відображатися на оригінальному об'єкті.
		   \param[in] CloningArray Масив, який потрібно клонувати в об’єкт
		   \since v1.0.0.0 commit a2f550
		   \note Якщо допускається, що зміни можуть впливати на обидва об'єкти, краще
		   використати ALGOR::ARRAYDATA::setData, якщо ще потрібно видалити старий
		   масив, тоді використовується ALGOR::ARRAYDATA::setNewData.
		   \note Якщо ж потрібно видалити старий масив, коли зміни не мають впливати
		   один на одного, тоді використовується ALGOR::ARRAYDATA::cloneNewData.
		   \sa ALGOR::ARRAYDATA::setNewData(Array<type_array> *&)
		   \sa ALGOR::ARRAYDATA::setData(Array<type_array> *&)
		   \sa ALGOR::ARRAYDATA::cloneNewData(Array<type_array> *&)
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA cloneData
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::getData()
		   \brief Повертає вказівник на структуру масиву
		   \details Цей метод використовується, якщо необхідно отримати данні масиву,
		   наприклад, для їх друку.
		   \warning Краще не обробляти масив ззовні об'єкту, інакше це може призвести
		   до непередбачуваної поведінки!
		   \return вказівник на структуру масиву.
		   \since v0.1.0.0 commit 48aa64
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA getData
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::getSize()
		   \brief Повертає розмір структури масиву
		   \return розмір структури масиву.
		   \since v0.1.3.0 commit 828901
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA getSize
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::getValue(const asize_t &)
		   \brief Повертає значення із заданої позиції
		   \details Використовується для знаходження значення у масиві по заданій
		   позиції. Є протилежним до методу ALGOR::ARRAYDATA::binary_getPosition.
		   \throw ALGOR::EXCEPTION_SET::memory_overflow
		   \param[in] position Позиція у масиві
		   \return значення із заданої позиції
		   \since v0.1.3.0 commit 5a7ff3
		   \sa ALGOR::ARRAYDATA::binary_getPosition(const type_array &)
		   \sa ALGOR::ARRAYDATA::lenear_getPosition(const type_array &)
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA getValue
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::binary_getPosition(const type_array &)
		   \brief Бінарний метод пошуку елемента
		   \details Повертає перше входження заданого елемента. Є протилежним до
		   методу ALGOR::ARRAYDATA::getValue.
		   \throw ALGOR::EXCEPTION_SET::not_found
		   \warning Для роботи алгоритму необхідно, щоб масив був відсортований!
		   \note Якщо необхідно знайти всі входження заданого елемента, необхідно
		   використати метод ALGOR::ARRAYDATA::lenear_getPosition, але він довше
		   виконується на великих масивах.
		   \param[in] required_element Елемент, позицію  якого потрібно знайти
		   \return першу позицію заданого елемента
		   \since v0.0.1.0 commit 0c1496
		   \sa ALGOR::ARRAYDATA::getValue(const asize_t &)
		   \sa ALGOR::ARRAYDATA::lenear_getPosition(const type_array &)
		   \remark За різних версій цей метод називався по різному. Самою першою його
		   назвою було "getElementNumber_binary".
		   \remark З першою реалізацією алгоритм було погано реалізовано - він
		   виконував поставлену задачу, але був досить неефективний через рекурсивну
		   реалізацію. У v0.1.3.0 commit 11507e реалізацію було переписано під
		   використання нових функцій ALGOR::ArrayProcessing::distance та
		   ALGOR::ArrayProcessing::lower_bound, котра у свою чергу є ітераційною
		   й використовуює лише вказівник, що є досить ефективно.
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA binary_getPosition
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::lenear_getPosition(const type_array &)
		   \brief Лінійний метод пошуку елемента
		   \details Повертає всі входження заданого елемента. Є розширенням методу
		   ALGOR::ARRAYDATA::binary_getPosition.
		   \throw ALGOR::EXCEPTION_SET::not_found
		   \note Якщо масив дуже великий і метод довго виконується, краще викликати
		   метод ALGOR::ARRAYDATA::binary_getPosition. Він менше навантажує
		   систему і набагато швидше виконується, але повертає лише першу позицію
		   заданого елемента, а перед його викликом масив необхідно відсортувати...
		   \param[in] required_element Елемент, позиції якого потрібно знайти
		   \return масив позицій заданого елемента
		   \since v0.0.1.0 commit 0c1496
		   \sa ALGOR::ARRAYDATA::getValue(const asize_t &)
		   \sa ALGOR::ARRAYDATA::binary_getPosition(const type_array &)
		   \remark За різних версій цей метод називався по різному. Самою першою його
		   назвою було "getElementNumber_lenear".
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA lenear_getPosition
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::getMin()
		   \brief Оптимізований метод пошуку мінімального елемента
		   \details Цей метод є оптимізованим, оскільки головний алгоритм пошуку
		   написано у методі ALGOR::ArrayProcessing::minimum і використовується
		   тільки тоді, коли масив відсортовано. Це дозволяє оптимізувати алгоритм
		   у деяких випадках, так як якщо масив не відсортовано, метод це зможе
		   визначити майже відразу й приступить до звичайного перебору, але якщо
		   буде визначено, що масив відсортовано, то для цього потрібно було пройти
		   по усьому масиву, і у цьому випадку це пройде швидше, так як не відбувається
		   жодних збережень данних до змінних, що є швидше, і після цієї оберації за
		   найменше буде видано перше значення, оскільки воно є найменшим у
		   відсортованому масиві. Таким чином у деяких випадках алгоритм буде
		   працювати стільки ж часу (якщо масив не відсортовано), і у деяких менше
		   (якщо масив відсортовано, а проходка з порівняннями займає менше часу, ніж
		   проходка з порівняннями та збереженнями данних), що у середньому буде
		   трохи швидше реалізації звичайною проходкою (як у алгоритмі
		   ALGOR::ArrayProcessing::minimum).
		   \return найменше значення у масиві
		   \since v0.1.0.0 commit 48aa64
		   \sa ALGOR::ArrayProcessing::minimum(const type_array *, const asize_t &)
		   \sa ALGOR::ARRAYDATA::getMax()
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA getMin
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::getMax()
		   \brief Оптимізований метод пошуку максимального елемента
		   \details Цей метод є оптимізованим, оскільки головний алгоритм пошуку
		   написано у методі ALGOR::ArrayProcessing::maximum і використовується
		   тільки тоді, коли масив відсортовано. Щоб не повторюватись, інші деталі
		   та пояснення описано у методі ALGOR::ARRAYDATA::getMin. Робота у цьому
		   методі пояснюється аналогічно, тільки замість мінімального елемента
		   виконується пошук максимального.
		   \return найбільше значення у масиві
		   \since v0.1.0.0 commit 48aa64
		   \sa ALGOR::ArrayProcessing::maximum(const type_array *, const asize_t &)
		   \sa ALGOR::ARRAYDATA::getMin()
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA getMax
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::reset()
		   \brief Метод збросу данних
		   \details Метод видаляє масив із пам'яті й виділяє заново пам'ять під
		   новий масив без його заповнення. У результаті масив буде спустошено
		   до нульових данних.
		   \since v0.1.0.0 commit 1f2a4f
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA reset
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::resize(const asize_t &, const type_array &)
		   \brief Метод, який змінює розмір масиву
		   \details Насправді, метод створює новий масив нового розміру і копіює
		   у нього старий масив. Якщо масив стає більше - нові комірки заповнюються
		   заданим значенням, інакше - останні значення відкидаються. Потім
		   пам'ять від старого масиву звільняється, а вказівник починає вказувати
		   на новий масив.
		   \throw ALGOR::EXCEPTION_SET::size_failure
		   \param[in] NEW_SIZE Новий розмір масиву
		   \param[in] setElement Значення, яким заповнюються нові клітинки масиву (у
		   випадку збільшення масиву)
		   \warning У разі збільшення розміру масиву після копіювання нові комірки
		   залишаються порожніми і зберігають у собі «сміття». Іноді програміст
		   випадково може спробувати отримати дані без їх вказівки, в результаті
		   чого в кращому випадку буде просто виданий некоректний результат, а в
		   гіршому - програма може вийти з ладу. Для цього був створений параметр
		   setElement, але його потрібно вказувати не тільки при збільшенні розміру,
		   а завжди при виклику методу для профілактики. Програміст може навіть
		   не знати поточного розміру масиву, отже, він не може знати, чи буде масив
		   збільшено чи зменшено.
		   \since v0.1.0.0 commit 1d50a2
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA resize
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::replace(const asize_t &, const type_array &)
		   \brief Змінює значення по вказаній позиції
		   \param[in] position Позиція, у якій змінюється значення
		   \param[in] value Значення, яке буде розміщено в позиції
		   \since v0.1.0.0 commit dd5d42
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA replace
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::reverse()
		   \brief Перевертає масив
		   \since v0.0.0.3 commit 05d8b0
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA reverse
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::respawn()
		   \brief Метод збросу та перегенерації данних
		   \details Метод розширює ALGOR::ARRAYDATA::reset, а саме додатково зберігає
		   діапазон значень масиву і після збросу даних, заново їх генерує.
		   \since v0.0.0.3 commit 05d8b0
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA respawn
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::searcherOccurrencesOfSubstring(Array<type_array> *&, ArrayType)
		   \brief Метод пошуку послідовності, який повертає всі її входження
		   \details Цей метод перебором визначає всі початкові позиції співпадінь
		   підрядку в головному ряді.
		   \throw ALGOR::EXCEPTION_SET::not_found
		   \param[in] SUBARRAY Підрядок, який шукається в основному ряді (масиві)
		   \param[in] ArrType Тип масиву (цифровий чи строковий)
		   \return всі перші номери входжень заданого підрядку
		   \since v0.0.1.0 commit e37003
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA searcherOccurrencesOfSubstring
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::average()
		   \brief Метод, який повертає середнє арифметичне значення масиву
		   \throw ALGOR::EXCEPTION_SET::division_by_zero
		   \return середнє арифметичне значення
		   \since v0.0.0.3 commit 1a11a0
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA average
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::mediana()
		   \brief Метод, який повертає медіану масиву
		   \return медіану масиву
		   \since v0.0.0.3 commit 1a11a0
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA mediana
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::moda()
		   \brief Метод, який повертає всі елементи моди масиву
		   \details Спочатку метод визначає моду масиву (з її першим значенням), а
		   потім за другим проходом (після визначеної моди) зберігає всі значення, що
		   відповідають знайденій моді.
		   \return моди масиву
		   \since v0.0.0.3 commit 1a11a0
		   \warning У різних версіях бібліотеки функціонал даного методу змінювався!
		   Із зазначеної версії функція повертала лише перше значення моди. З
		   <i>v0.0.1.0 commit 979bf4</i> з'явилась додаткова функція modas(), яка
		   була призначена для знаходження всіх мод масиву (насправді, вона базувалась
		   на використанні першої функції, а отриманні данні використовувала для
		   знаходження всіх інших значень, що відповідають моді). А коли у
		   <i>v0.1.3.0 commit 391fff</i> було написано окрему структуру для моди і
		   тепер обидва методи почали працювати з одним типом даних - масивом мод, але
		   перша функція повертає лище перше значення моди, тоді як друга - усі.
		   Тоді було вирішено об'єднати ці методи в один, зберігши назву першого.
		   <u>За різних версій з цим методом потрібно працювати по різному!</u>
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA moda
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::operator=(Array<type_array> *&)
		   \brief Клонує масив, як окремий
		   \details Більш легкий спосіб використання функції
		   ALGOR::ARRAYDATA::cloneNewData. Якщо клонування відбулось успішно,
		   повертається <i>true</i>, інакше - <i>false</i>.
		   \param[in] cloningArray Масив, який потрібно клонувати в об’єкт
		   \return логічну відповідь, чи відбулось клонування
		   \since v0.1.3.0 commit 045729
		   \sa ALGOR::ARRAYDATA::cloneNewData(Array<type_array> *&)
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA =
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::operator==(Array<type_array> *&)
		   \brief Порівнює різні масиви на однаковість
		   \details Перевіряє кожен елемент наданого масиву з кожним поточним і
		   якщо всі елементи рівні - масиви однакові (можливо, вони просто
		   клоновані...).
		   \param[in] anotherArray Масив, який порівнюється з поточним об'єктом
		   \return логічну відповідь, чи однакові масиви
		   \since v0.1.3.0 commit 045729
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA ==
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::operator^=(const asize_t &)
		   \brief Оператор зміни розміру масиву
		   \details Більш легкий спосіб використання функції
		   ALGOR::ARRAYDATA::resize.
		   \throw ALGOR::EXCEPTION_SET::size_failure
		   \param[in] NewSize Новий розмір масиву
		   \return вказівник на нову структуру масиву
		   \since v0.1.3.0 commit 045729
		   \warning Цей оператор було введено на заміну старим реалізаціям
		   операторів +, -, * та /. У <i>v0.1.3.0 commit ae17f6</i> було дуже сильно
		   оптимізовано дані оператори, що було виявлено їх однакові закономірності,
		   що дозволило їх об'єднати до одного оператора ^=. Самі початкові
		   оператори були переписані під використання інших дій.
		   \sa ALGOR::ARRAYDATA::resize(const asize_t &, const type_array &)
		   \sa ALGOR::ARRAYDATA::operator+=(const type_array &)
		   \sa ALGOR::ARRAYDATA::operator-=(const type_array &)
		   \sa ALGOR::ARRAYDATA::operator*=(const type_array &)
		   \sa ALGOR::ARRAYDATA::operator/=(const type_array &)
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA ^=
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::operator+=(const type_array &)
		   \brief Збільшує кожен елемент масиву на певне значення
		   \param[in] addValue Параметр, що вказує, наскільки збільшити кожен
		   елемент масиву
		   \return вказівник на нову структуру масиву
		   \since v0.1.0.0 commit 1f2a4f
		   \warning Цей оператор було реалізовано для збільшення розміру масиву.
		   У <i>v0.1.3.0 commit ae17f6</i> було дуже сильно оптимізовано оператори
		   +, -, *, /, і його реалізацію було винесено до окремого оператора ^=, а
		   за цим оператором було вирішено залишити збільшення кожного елементу.
		   \sa ALGOR::ARRAYDATA::operator^=(const asize_t &)
		   \sa ALGOR::ARRAYDATA::operator-=(const type_array &)
		   \sa ALGOR::ARRAYDATA::operator*=(const type_array &)
		   \sa ALGOR::ARRAYDATA::operator/=(const type_array &)
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA +=
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::operator-=(const type_array &)
		   \brief Зменшує кожен елемент масиву на певне значення
		   \param[in] subtractValue Параметр, що вказує, наскільки зменшити кожен
		   елемент масиву
		   \return вказівник на нову структуру масиву
		   \since v0.1.0.0 commit 1f2a4f
		   \warning Цей оператор було реалізовано для зменшення розміру масиву.
		   У <i>v0.1.3.0 commit ae17f6</i> було дуже сильно оптимізовано оператори
		   +, -, *, /, і його реалізацію було винесено до окремого оператора ^=, а
		   за цим оператором було вирішено залишити зменшення кожного елементу.
		   \sa ALGOR::ARRAYDATA::operator^=(const asize_t &)
		   \sa ALGOR::ARRAYDATA::operator+=(const type_array &)
		   \sa ALGOR::ARRAYDATA::operator*=(const type_array &)
		   \sa ALGOR::ARRAYDATA::operator/=(const type_array &)
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA -=
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::operator*=(const type_array &)
		   \brief Збільшує кожен елемент масиву у скількісь разів
		   \param[in] multiplyValue Параметр, що вказує, у скільки разів
		   збільшити кожен елемент масиву
		   \return вказівник на нову структуру масиву
		   \since v0.1.0.0 commit dd5d42
		   \warning Цей оператор було реалізовано для кратного збільшення розміру
		   масиву. У <i>v0.1.3.0 commit ae17f6</i> було дуже сильно оптимізовано
		   оператори +, -, *, /, і його реалізацію було винесено до окремого
		   оператора ^=, а за цим оператором було вирішено залишити кратне
		   збільшення кожного елементу.
		   \sa ALGOR::ARRAYDATA::operator^=(const asize_t &)
		   \sa ALGOR::ARRAYDATA::operator+=(const type_array &)
		   \sa ALGOR::ARRAYDATA::operator-=(const type_array &)
		   \sa ALGOR::ARRAYDATA::operator/=(const type_array &)
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA *=
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::operator/=(const type_array &)
		   \brief Зменшує кожен елемент масиву у скількісь разів
		   \param[in] divideValue Параметр, що вказує, у скільки разів
		   зменшити кожен елемент масиву
		   \return вказівник на нову структуру масиву
		   \since v0.1.0.0 commit dd5d42
		   \warning Цей оператор було реалізовано для кратного зменшення розміру
		   масиву. У <i>v0.1.3.0 commit ae17f6</i> було дуже сильно оптимізовано
		   оператори +, -, *, /, і його реалізацію було винесено до окремого
		   оператора ^=, а за цим оператором було вирішено залишити кратне
		   зменшення кожного елементу.
		   \sa ALGOR::ARRAYDATA::operator^=(const asize_t &)
		   \sa ALGOR::ARRAYDATA::operator+=(const type_array &)
		   \sa ALGOR::ARRAYDATA::operator-=(const type_array &)
		   \sa ALGOR::ARRAYDATA::operator*=(const type_array &)
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA /=
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::operator&=(const type_array &)
		   \brief Оператор додавання елемента в кінець масиву
		   \details Більш легкий спосіб використання функції
		   ALGOR::ArrayProcessing::addElement.
		   \note Функція ALGOR::ArrayProcessing::addElement є дуже гнучкою і
		   дозволяє додавати елемент на любу позицію масиву, тому якщо потрібно
		   додати елемент не у кінець масиву - прийдеться використовувати
		   функцію власноруч...
		   \remark Якщо бути чесним, то цей оператор було додано лише для
		   можливості спрощеного легкого використання стандартним масивних
		   функцій при роботі з об'єктами.
		   \param[in] value Елемент, який потрібно додати до масиву
		   \return вказівник на нову структуру масиву
		   \since v0.1.0.0 commit dd5d42
		   \sa ALGOR::ArrayProcessing::addElement(type_array *&, asize_t &, const type_array &, const asize_t)
		   \sa ALGOR::ARRAYDATA::operator|=(const type_array &)
		   \sa ALGOR::ARRAYDATA::operator!()
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA &=
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::operator|=(const type_array &)
		   \brief Оператор, який видаляє всі елементи з указаним значенням
		   \details Більш легкий спосіб використання функції
		   ALGOR::ArrayProcessing::subtractValue.
		   \remark Якщо бути чесним, то цей оператор було додано лише для
		   можливості спрощеного легкого використання стандартним масивних
		   функцій при роботі з об'єктами.
		   \param[in] value Значення, яке потрібно видалити з усього масиву
		   \return вказівник на нову структуру масиву
		   \since v0.1.0.0 commit dd5d42
		   \sa ALGOR::ArrayProcessing::subtractValue(type_array *&, asize_t &, const type_array &)
		   \sa ALGOR::ARRAYDATA::operator&=(const type_array &)
		   \sa ALGOR::ARRAYDATA::operator!()
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA |=
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::operator!()
		   \brief Оператор, який видаляє елемент із кінця масиву
		   \details Більш легкий спосіб використання функції
		   ALGOR::ArrayProcessing::subtractElement.
		   \remark Якщо бути чесним, то цей оператор було додано лише для
		   можливості спрощеного легкого використання стандартним масивних
		   функцій при роботі з об'єктами.
		   \return вказівник на нову структуру масиву
		   \since v0.1.0.0 commit dd5d42
		   \sa ALGOR::ArrayProcessing::subtractElement(type_array *&, asize_t &, const asize_t)
		   \sa ALGOR::ARRAYDATA::operator&=(const type_array &)
		   \sa ALGOR::ARRAYDATA::operator|=(const type_array &)
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA !
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::operator<<=(ARRAYDATA<type_array> *&)
		   \brief Оператор об'єднання двох масивів у поточному об'єкті
		   \details Оператор додає данні із наданого об'єкту у кінець поточного
		   об'єкту. Це єдиний метод, який працює не зі структурами, а із об'єктами.
		   \param[in] appendingArray Масив, з якого будуть передаватись данні до
		   поточного
		   \return вказівник на нову структуру масиву
		   \since v0.1.0.0 commit dd5d42
		   \sa ALGOR::ARRAYDATA::operator>>=(ARRAYDATA<type_array> *&)
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA <<=
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::operator>>=(ARRAYDATA<type_array> *&)
		   \brief Оператор об'єднання двох масивів у наданому об'єкті
		   \details Оператор додає данні із поточного об'єкту у кінець наданого
		   об'єкту. Це єдиний метод, який працює не зі структурами, а із об'єктами.
		   \param[out] appendingArray Масив, у який будуть передаватись данні з
		   поточного
		   \return вказівник на нову структуру масиву
		   \since v0.1.0.0 commit dd5d42
		   \sa ALGOR::ARRAYDATA::operator<<=(ARRAYDATA<type_array> *&)
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA >>=
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::remove()
		   \brief Видаляє масив
		   \warning Метод є приватним, щоб уникнути випадків, коли програміст
		   звільнив пам'ять з-під масиву і звертається до пустих данних чи намагається
		   проводити над ними якісь зміни.
		   \since v0.1.0.0 commit 1d50a2
		 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                ALGOR_SORTING                                *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

	/*!
	   \class ALGOR::Comparative_Sorts
	   \brief Клас з великою кількістю алгоритмів сортувань

	   \details Клас, що колекціонує велику кількість алгоритмів сортувань. Саме
	   така мета ставилася на початку створення бібліотеки: реалізувати усі
	   алгоритми сортувань! Але з часом ставились інші цілі, окрім алгоритмів
	   сортувань, що призвело до розширення функціоналу бібліотеки... Тільки з
	   часом я повернувся до реалізації алгоритмів сортувань. На Вікіпедії
	   доступно 50 різних алгоритмів сортувань, які поділені на категорії.
	   Додатково я їх поділив ще на два великі сімейства: алгоритми, що працюють
	   з будь-якими числовими данними та алгоритми, що працюють тільки з цілими
	   числовими данними. Цей клас реалізує перше сімейство алгоритмів. Його частка
	   складає 40 алгоритмів із 50.

	   \details Під час роботи я зрозумів, що зможу реалізувати не всі алгоритми, так
	   як деякі просто не достанеш. При пошуках CascadeMergeSort на Вікіпедії
	   описано усього півтори строчки про алгоритм, а при переході за посиланням
	   на ресурс надається книга з 584 сторінки, доступно з яких не більше 10. І
	   більше ніде ніякої інформації не має... І це лише один з прикладів...

	   \details Із 40 я зміг реалізувати 22 алгоритми даного сімейства:
	   1. Batcher_OddEven_MergeSort	(Категорія Concurrent_Sort)
	   2. Bitonic_Sorter			(Категорія Concurrent_Sort)
	   3. Bogo_Sort					(Категорія Exchange_Sorts)
	   4. Bubble_Sort				(Категорія Exchange_Sorts)
	   5. Cocktail_Shaker_Sort		(Категорія Exchange_Sorts)
	   6. Comb_Sort					(Категорія Exchange_Sorts)
	   7. Cycle_Sort				(Категорія Selection_Sorts)
	   8. Gnome_Sort				(Категорія Exchange_Sorts)
	   9. Heap_Sort					(Категорія Selection_Sorts)
	   10. Insert_Sort				(Категорія Insertion_Sorts)
	   11. Library_Sort				(Категорія Insertion_Sorts)
	   12. Merge_Sort				(Категорія Merge_Sorts)
	   13. Odd_Even_Sort			(Категорія Exchange_Sorts)
	   14. Pancake_Sort				(Категорія Other_Sorts)
	   15. Patience_Sort			(Категорія Insertion_Sorts)
	   16. Quick_Sort				(Категорія Exchange_Sorts)
	   17. Selection_Sort			(Категорія Selection_Sorts)
	   18. Shell_Sort				(Категорія Insertion_Sorts)
	   19. Slow_Sort				(Категорія Exchange_Sorts)
	   20. Stooge_Sort				(Категорія Exchange_Sorts)
	   21. Tim_Sort					(Категорія Hybrid_Sorts)
	   22. Tree_Sort				(Категорія Insertion_Sorts)

	   \details Не реалізованими залишились:
	   1. ProportionExtendSort		(Категорія Exchange_Sorts)
	   2. Smooth_Sort				(Категорія Selection_Sorts)
	   3. CartesianTreeSort			(Категорія Selection_Sorts)
	   4. TournamentSort			(Категорія Selection_Sorts)
	   5. WeakHeapSort				(Категорія Selection_Sorts)
	   6. SplaySort					(Категорія Insertion_Sorts)
	   7. CascadeMergeSort			(Категорія Merge_Sorts)
	   8. OscillatingMergeSort		(Категорія Merge_Sorts)
	   9. PolyphaseMergeSort		(Категорія Merge_Sorts)
	   10. PairwiseSortingNetwork	(Категорія Concurrent_Sort)
	   11. SampleSort				(Категорія Concurrent_Sort)
	   12. BlockMergeSort			(Категорія Hybrid_Sorts)
	   13. KirkpatrickReischSort	(Категорія Hybrid_Sorts)
	   14. IntroSort				(Категорія Hybrid_Sorts)
	   15. SpreadSort				(Категорія Hybrid_Sorts)
	   16. MergeInsertionSort		(Категорія Hybrid_Sorts)
	   17. TopologicalSort			(Категорія Other_Sorts)
	   18. SpaghettiSort			(Категорія Other_Sorts)

	   \remark Нагадаю, що усі ці алгоритми працюють з будь-якими данними, тобто і
	   з цілими, і з дробними, і з додатніми, і з від'ємними, і зі змішаними. Ця
	   характеристика під час тестування мала визначення:
	   "цілі+ цілі- цілі+- дрібні+ дрібні- дрібні+-".

	   \tparam type_array Тип елементів, що будуть сортуватися
	   \since v0.1.2.0 commit 52d263
	 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Comparative_Sorts(Array<type_array> *&)
		   \brief Конструктор, що приймає СТРУКТУРУ та зберігає її до поля
		   \details Цей клас, як сімейство, як колекціонер, збирає алгоритми
		   сортувань, як внутрішні класи, але дозволяє до них прямий доступ.
		   Якщо бібліотека використовується тільки як джерело алгоритмів сортувань,
		   тоді краще створити напряму об'єкт внутрішнього класу алгоритму сортувань,
		   передати йому стандатний С++ вказівник на масив та його розмір й викликати
		   метод сортувань. Але якщо бібліотека ALGOR використовується у більшому
		   спектрі, тоді набагато легше буде створити об'єкт сімейства, передати
		   йому готову структуру й викликати потрібний алгоритми. Порівняйте:
		   \code
		   //Використання алгоритму напряму
		   Comparative_Sorts<long long>::LibrarySort *sort;
		   sort = new Comparative_Sorts<long long>::LibrarySort(ArrayStruct->array, ArrayStruct->array_size);
		   sort->library_sort();
		   //Використання алгоритму через зовнішній клас
		   Comparative_Sorts<long long> *sort = new Comparative_Sorts<long long>(ArrayStruct);
		   sort->Library_Sort();
		   \endcode
		   \param[in] Array Покажчик на структуру масиву
		   \since v0.1.2.0 commit 52d263
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts constructor
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Bubble_Sort()
		   \brief Метод виклику алгоритму сортування Bubble Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::BubbleSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.2 commit 46c223
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Bubble_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Cocktail_Shaker_Sort()
		   \brief Метод виклику алгоритму сортування Cocktail Shaker Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::CocktailShakerSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.2 commit 46c223
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Cocktail_Shaker_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Odd_Even_Sort()
		   \brief Метод виклику алгоритму сортування Odd Even Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::OddEvenSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.2 commit 46c223
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Odd_Even_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Comb_Sort()
		   \brief Метод виклику алгоритму сортування Comb Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::CombSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.2 commit 46c223
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Comb_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Gnome_Sort()
		   \brief Метод виклику алгоритму сортування Gnome Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::GnomeSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.2 commit 46c223
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Gnome_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Quick_Sort()
		   \brief Метод виклику алгоритму сортування Quick Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::QuickSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.2 commit 46c223
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Quick_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Slow_Sort()
		   \brief Метод виклику алгоритму сортування Slow Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::SlowSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.2 commit 46c223
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Slow_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Stooge_Sort()
		   \brief Метод виклику алгоритму сортування Stooge Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::StoogeSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.2 commit 46c223
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Stooge_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Bogo_Sort()
		   \brief Метод виклику алгоритму сортування Bogo Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::BogoSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.2 commit 46c223
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Bogo_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Selection_Sort()
		   \brief Метод виклику алгоритму сортування Selection Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::SelectionSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.2 commit 28f51f
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Selection_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Heap_Sort()
		   \brief Метод виклику алгоритму сортування Heap Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::HeapSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.2 commit 28f51f
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Heap_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Cycle_Sort()
		   \brief Метод виклику алгоритму сортування Cycle Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::CycleSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.2 commit 28f51f
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Cycle_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Insert_Sort()
		   \brief Метод виклику алгоритму сортування Insert Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::InsertSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.3 commit f81852
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Insert_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Shell_Sort()
		   \brief Метод виклику алгоритму сортування Shell Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::ShellSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.3 commit f81852
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Shell_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Tree_Sort()
		   \brief Метод виклику алгоритму сортування Tree Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::TreeSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.3 commit f81852
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Tree_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Library_Sort()
		   \brief Метод виклику алгоритму сортування Library Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::LibrarySort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.3 commit b4cdc9
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Library_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Patience_Sort()
		   \brief Метод виклику алгоритму сортування Patience Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::PatienceSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.3 commit f81852
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Patience_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Merge_Sort()
		   \brief Метод виклику алгоритму сортування Merge Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::MergeSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.1.4 commit b19f70
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Merge_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Bitonic_Sorter()
		   \brief Метод виклику алгоритму сортування Bitonic Sorter
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::BitonicSorter. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.2.1 commit ffc19f
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Bitonic_Sorter
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Batcher_OddEven_MergeSort()
		   \brief Метод виклику алгоритму сортування Batcher Odd Even Merge Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::BatcherOddEvenMergeSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.3.0 commit 98b663
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Batcher_OddEven_MergeSort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Tim_Sort()
		   \brief Метод виклику алгоритму сортування Tim Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::TimSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.2.1 commit ffc19f
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Tim_Sort
		 */

		/*!
		   \fn ALGOR::Comparative_Sorts::Pancake_Sort()
		   \brief Метод виклику алгоритму сортування Pancake Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Comparative_Sorts::PancakeSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.2.1 commit ffc19f
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts Pancake_Sort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::BatcherOddEvenMergeSort
		   \brief Алгоритм сортування Batcher Odd-Even Merge Sort
		   \par Категорія
		   <b>Concurrent Sort</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Batcher_odd%E2%80%93even_mergesort</i>
		   \since v0.1.3.0 commit 98b663
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts BatcherOddEvenMergeSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::BitonicSorter
		   \brief Алгоритм сортування Bitonic Sorter
		   \par Категорія
		   <b>Concurrent Sort</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Bitonic_sorter</i>
		   \since v0.1.1.2 commit 303e5b
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts BitonicSorter
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::BogoSort
		   \brief Алгоритм сортування Bogo Sort
		   \par Категорія
		   <b>Exchange Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Bogosort</i>
		   \since v0.1.1.1 commit f338fc
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts BogoSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::BubbleSort
		   \brief Алгоритм сортування Bubble Sort
		   \par Категорія
		   <b>Exchange Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Bubble_sort</i>
		   \since v0.0.0.1
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts BubbleSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::CocktailShakerSort
		   \brief Алгоритм сортування Cocktail Shaker Sort
		   \par Категорія
		   <b>Exchange Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Cocktail_shaker_sort</i>
		   \since v0.0.0.1
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts CocktailShakerSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::CombSort
		   \brief Алгоритм сортування Comb Sort
		   \par Категорія
		   <b>Exchange Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Comb_sort</i>
		   \since v0.1.1.1 commit f338fc
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts CombSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::CycleSort
		   \brief Алгоритм сортування Cycle Sort
		   \par Категорія
		   <b>Selection Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Cycle_sort</i>
		   \since v0.1.1.2 commit 49dffe
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts CycleSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::GnomeSort
		   \brief Алгоритм сортування Gnome Sort
		   \par Категорія
		   <b>Exchange Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Gnome_sort</i>
		   \since v0.1.1.1 commit f338fc
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts GnomeSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::HeapSort
		   \brief Алгоритм сортування Heap Sort
		   \par Категорія
		   <b>Selection Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Heapsort</i>
		   \since v0.0.0.1
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts HeapSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::InsertSort
		   \brief Алгоритм сортування Insert Sort
		   \par Категорія
		   <b>Insertion Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Insertion_sort</i>
		   \since v0.0.0.1
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts InsertSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::LibrarySort
		   \brief Алгоритм сортування Library Sort
		   \par Категорія
		   <b>Insertion Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Library_sort</i>
		   \since v0.1.1.3 commit b4cdc9
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts LibrarySort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::MergeSort
		   \brief Алгоритм сортування Merge Sort
		   \par Категорія
		   <b>Merge Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Merge_sort</i>
		   \since v0.0.0.1
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts MergeSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::OddEvenSort
		   \brief Алгоритм сортування Odd-Even Sort
		   \par Категорія
		   <b>Exchange Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort</i>
		   \since v0.1.1.1 commit f338fc
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts OddEvenSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::PancakeSort
		   \brief Алгоритм сортування Pancake Sort
		   \par Категорія
		   <b>Other Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Pancake_sorting</i>\n
		   \since v0.1.1.2 commit 303e5b
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts PancakeSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::PatienceSort
		   \brief Алгоритм сортування Patience Sort
		   \par Категорія
		   <b>Insertion Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Patience_sorting</i>
		   \since v0.1.1.2 commit 343e40
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts PatienceSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::QuickSort
		   \brief Алгоритм сортування Quick Sort
		   \par Категорія
		   <b>Exchange Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Quicksort</i>
		   \since v0.0.0.1
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts QuickSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::SelectionSort
		   \brief Алгоритм сортування Selection Sort
		   \par Категорія
		   <b>Selection Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Selection_sort</i>
		   \since v0.1.1.1 commit f338fc
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts SelectionSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::ShellSort
		   \brief Алгоритм сортування Shell Sort
		   \par Категорія
		   <b>Insertion Sorts</b>
		   \par Ресурси
		   <i>https://en.wikipedia.org/wiki/Shellsort</i>
		   \since v0.1.1.1 commit 800c0d
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts ShellSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::SlowSort
		   \brief Алгоритм сортування Slow Sort
		   \par Категорія
		   <b>Exchange Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Slowsort</i>
		   \since v0.1.1.1 commit 800c0d
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts SlowSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::StoogeSort
		   \brief Алгоритм сортування Stooge Sort
		   \par Категорія
		   <b>Exchange Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Stooge_sort</i>
		   \since v0.1.1.1 commit f338fc
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts StoogeSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::TimSort
		   \brief Алгоритм сортування Tim Sort
		   \par Категорія
		   <b>Hybrid Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Timsort</i>
		   \since v0.1.1.4 commit 090b06
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts TimSort
		 */

		/*!
		   \class ALGOR::Comparative_Sorts::TreeSort
		   \brief Алгоритм сортування Tree Sort
		   \par Категорія
		   <b>Insertion Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Tree_sort</i>
		   \since v0.1.1.2 commit 343e40
		   \test
		   \snippet Algor_ArraySort.cpp Comparative_Sorts TreeSort
		 */

			/*!
			   \struct ALGOR::Comparative_Sorts::TreeSort::Tree
			   \brief Дерево данних, яке потрібне для сортування
			   \since v0.1.1.2 commit 343e40
			 */

	/*!
	   \class ALGOR::Distribution_Sorts
	   \brief Клас із потужними алгоритмами сортувань

	   \details Клас, що колекціонує потужні алгоритми сортувань. Цей клас є
	   виокремленим, так як він працює не з усіма типами данних, як працюють
	   алгоритми сімейства ALGOR::Comparative_Sorts, а тільки з цілочисельними
	   данними.

	   \details На Вікіпедії доступно 50 різних алгоритмів сортувань, які поділені
	   на категорії. Додатково я їх поділив ще на два великі сімейства: алгоритми,
	   що працюють з будь-якими числовими данними та алгоритми, що працюють тільки
	   з цілими числовими данними. Цей клас реалізує друге сімейство алгоритмів.
	   Його частка складає 10 алгоритмів із 50.

	   \details Під час роботи я зрозумів, що зможу реалізувати не всі алгоритми, так
	   як деякі просто не достанеш. При пошуках CascadeMergeSort на Вікіпедії
	   описано усього півтори строчки про алгоритм, а при переході за посиланням
	   на ресурс надається книга з 584 сторінки, доступно з яких не більше 10. І
	   більше ніде ніякої інформації не має... І це лише один з прикладів...

	   \details Із 10 я зміг реалізувати 8 алгоритмів даного сімейства:
	   1. AmericanFlag_Sort	(Категорія Distribution_Sorts)
	   2. Bead_Sort			(Категорія Distribution_Sorts)
	   3. Bucket_Sort					(Категорія Distribution_Sorts)
	   4. Counting_Sort				(Категорія Distribution_Sorts)
	   5. Flash_Sort		(Категорія Distribution_Sorts)
	   6. Interpolation_Sort					(Категорія Distribution_Sorts)
	   7. Pigeonhole_Sort				(Категорія Distribution_Sorts)
	   8. Radix_Sort				(Категорія Distribution_Sorts)

	   \details Не реалізованими залишились:
	   1. BurstSort		(Категорія Distribution_Sorts)
	   2. ProxmapSort				(Категорія Distribution_Sorts)

	   \remark Нагадаю, цо ці алгоритми працюють НЕ з будь-якими данними, а тільки
	   з цілими числами. До того ж ALGOR::Distribution_Sorts::AmericanFlag_Sort,
	   ALGOR::Distribution_Sorts::Bead_Sort та
	   ALGOR::Distribution_Sorts::Radix_Sort не працюють з від'ємними цілими данними.

	   \since v0.1.2.0 commit 197603
	 */

		/*!
		   \fn ALGOR::Distribution_Sorts::Distribution_Sorts(Array<byte8_t> *&)
		   \brief Конструктор, що приймає СТРУКТУРУ та зберігає її до поля
		   \details Цей клас, як сімейство, як колекціонер, збирає алгоритми
		   сортувань, як внутрішні класи, але дозволяє до них прямий доступ.
		   Якщо бібліотека використовується тільки як джерело алгоритмів сортувань,
		   тоді краще створити напряму об'єкт внутрішнього класу алгоритму сортувань,
		   передати йому стандатний С++ вказівник на масив та його розмір й викликати
		   метод сортувань. Але якщо бібліотека ALGOR використовується у більшому
		   спектрі, тоді набагато легше буде створити об'єкт сімейства, передати
		   йому готову структуру й викликати потрібний алгоритми. Порівняйте:
		   \code
		   //Використання алгоритму напряму
		   Distribution_Sorts::CountingSort *sort;
		   sort = new Distribution_Sorts::CountingSort(ArrayStruct->array, ArrayStruct->array_size);
		   sort->counting_sort();
		   //Використання алгоритму через зовнішній клас
		   Distribution_Sorts *sort = new Distribution_Sorts(ArrayStruct);
		   sort->Counting_Sort();
		   \endcode
		   \warning Клас працює тільки з масивами типу <b>long long</b>!!!
		   \param[in] Array Покажчик на структуру масиву
		   \since v0.1.2.0 commit 197603
		   \test
		   \snippet Algor_ArraySort.cpp Distribution_Sorts constructor
		 */

		/*!
		   \fn ALGOR::Distribution_Sorts::AmericanFlag_Sort()
		   \brief Метод виклику алгоритму сортування American Flag Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Distribution_Sorts::AmericanFlagSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.2.0 commit 197603
		   \test
		   \snippet Algor_ArraySort.cpp Distribution_Sorts AmericanFlag_Sort
		 */

		/*!
		   \fn ALGOR::Distribution_Sorts::Bead_Sort()
		   \brief Метод виклику алгоритму сортування Bead Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Distribution_Sorts::BeadSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.2.0 commit 197603
		   \test
		   \snippet Algor_ArraySort.cpp Distribution_Sorts Bead_Sort
		 */

		/*!
		   \fn ALGOR::Distribution_Sorts::Bucket_Sort()
		   \brief Метод виклику алгоритму сортування Bucket Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Distribution_Sorts::BucketSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.2.0 commit 197603
		   \test
		   \snippet Algor_ArraySort.cpp Distribution_Sorts Bucket_Sort
		 */

		/*!
		   \fn ALGOR::Distribution_Sorts::Counting_Sort()
		   \brief Метод виклику алгоритму сортування Counting Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Distribution_Sorts::CountingSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.2.0 commit 197603
		   \test
		   \snippet Algor_ArraySort.cpp Distribution_Sorts Counting_Sort
		 */

		/*!
		   \fn ALGOR::Distribution_Sorts::Interpolation_Sort()
		   \brief Метод виклику алгоритму сортування Interpolation Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Distribution_Sorts::InterpolationSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.2.0 commit 197603
		   \test
		   \snippet Algor_ArraySort.cpp Distribution_Sorts Interpolation_Sort
		 */

		/*!
		   \fn ALGOR::Distribution_Sorts::Pigeonhole_Sort()
		   \brief Метод виклику алгоритму сортування Pigeonhole Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Distribution_Sorts::PigeonholeSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.2.0 commit 197603
		   \test
		   \snippet Algor_ArraySort.cpp Distribution_Sorts Pigeonhole_Sort
		 */

		/*!
		   \fn ALGOR::Distribution_Sorts::Radix_Sort()
		   \brief Метод виклику алгоритму сортування Radix Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Distribution_Sorts::RadixSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.2.0 commit 197603
		   \test
		   \snippet Algor_ArraySort.cpp Distribution_Sorts Radix_Sort
		 */

		/*!
		   \fn ALGOR::Distribution_Sorts::Flash_Sort()
		   \brief Метод виклику алгоритму сортування Flash Sort
		   \details Цей метод використовується для виклику алгоритму сортування
		   ALGOR::Distribution_Sorts::FlashSort. Метод не потребує
		   даних, так як вони були збережені при створенні об'єкта і власноруч
		   передає всі потрібні данні внутрішньому алгоритму сортування, що
		   спрощує написання коду.
		   \since v0.1.2.0 commit 197603
		   \test
		   \snippet Algor_ArraySort.cpp Distribution_Sorts Flash_Sort
		 */

		/*!
		   \class ALGOR::Distribution_Sorts::AmericanFlagSort
		   \brief Алгоритм сортування American Flag Sort
		   \par Категорія
		   <b>Distribution Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/American_flag_sort</i>\n
		   <i>Code: https://github.com/phishman3579/java-algorithms-implementation/blob/master/src/com/jwetherell/algorithms/sorts/AmericanFlagSort.java</i>
		   \par Сертифікат тестування
		   <i>Certificate "цілі+ ; вилітає"</i>
		   \since v0.1.2.0 commit f6f6fe
		   \test
		   \snippet Algor_ArraySort.cpp Distribution_Sorts AmericanFlagSort
		 */

		/*!
		   \class ALGOR::Distribution_Sorts::BeadSort
		   \brief Алгоритм сортування Bead Sort
		   \par Категорія
		   <b>Distribution Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Bead_sort</i>
		   \par Сертифікат тестування
		   <i>Certificate "цілі+ ; обрізає"</i>
		   \since v0.1.1.4 commit b19f70
		   \test
		   \snippet Algor_ArraySort.cpp Distribution_Sorts BeadSort
		 */

		/*!
		   \class ALGOR::Distribution_Sorts::BucketSort
		   \brief Алгоритм сортування Bucket Sort
		   \par Категорія
		   <b>Distribution Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Bucket_sort</i>\n
		   <i>Code: https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/bucket_sort.cpp</i>
		   \par Сертифікат тестування
		   <i>Certificate "цілі+ цілі- цілі+-"</i>
		   \since v0.1.1.4 commit b19f70
		   \test
		   \snippet Algor_ArraySort.cpp Distribution_Sorts BucketSort
		 */

		/*!
		   \class ALGOR::Distribution_Sorts::CountingSort
		   \brief Алгоритм сортування Counting Sort
		   \par Категорія
		   <b>Distribution Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Counting_sort</i>
		   \par Сертифікат тестування
		   <i>Certificate "цілі+ цілі- цілі+-"</i>
		   \since v0.0.0.1
		   \test
		   \snippet Algor_ArraySort.cpp Distribution_Sorts CountingSort
		 */

		/*!
		   \class ALGOR::Distribution_Sorts::FlashSort
		   \brief Алгоритм сортування Flash Sort
		   \par Категорія
		   <b>Distribution Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Flashsort</i>\n
		   <i>Code: https://javascript.algorithmexamples.com/web/Sorts/flashSort.html</i>
		   \par Сертифікат тестування
		   <i>Certificate "цілі+ цілі- цілі+-"</i>
		   \since v0.1.2.0 commit d74cc1
		   \test
		   \snippet Algor_ArraySort.cpp Distribution_Sorts FlashSort
		 */

		/*!
		   \class ALGOR::Distribution_Sorts::InterpolationSort
		   \brief Алгоритм сортування Interpolation Sort
		   \par Категорія
		   <b>Distribution Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Interpolation_sort</i>\n
		   <i>Code: https://github.com/aniketsatarkar/Sorting-Algorithms-in-C/blob/master/InterpolationSort.h</i>
		   \par Сертифікат тестування
		   <i>Certificate "цілі+ цілі- цілі+-"</i>
		   \since v0.1.2.0 commit d3274a
		   \test
		   \snippet Algor_ArraySort.cpp Distribution_Sorts InterpolationSort
		 */

		/*!
		   \class ALGOR::Distribution_Sorts::PigeonholeSort
		   \brief Алгоритм сортування Pigeonhole Sort
		   \par Категорія
		   <b>Distribution Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Pigeonhole_sort</i>
		   \par Сертифікат тестування
		   <i>Certificate "цілі+ цілі- цілі+-"</i>
		   \since v0.1.1.4 commit 090b06
		   \test
		   \snippet Algor_ArraySort.cpp Distribution_Sorts PigeonholeSort
		 */

		/*!
		   \class ALGOR::Distribution_Sorts::RadixSort
		   \brief Алгоритм сортування Radix Sort
		   \par Категорія
		   <b>Distribution Sorts</b>
		   \par Ресурси
		   <i>Source: https://en.wikipedia.org/wiki/Radix_sort</i>
		   \par Сертифікат тестування
		   <i>Certificate "цілі+ ; не сортує"</i>
		   \since v0.0.0.1
		   \test
		   \snippet Algor_ArraySort.cpp Distribution_Sorts RadixSort
		 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                 ALGOR_MATRIX                                *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

/*!
Matrix
*/

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                  ALGOR_HEAP                                 *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

/*!
Heap
*/

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                  ALGOR_LIST                                 *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

/*!
List
*/