/* **************************   DOCUMENTATION.dox   ************************** *
 * --------------------------------------------------------------------------- *
 *                                                                             *
 * Copyright © 2022 Kalynovsky Valentin. All rights reserved.                  *
 *                                                                             *
 * Licensed under the Apache License, Version 2.0 (the "License");             *
 * you may not use this file except in compliance with the License.            *
 * You may obtain a copy of the License at                                     *
 *                                                                             *
 *     http://www.apache.org/licenses/LICENSE-2.0                              *
 *                                                                             *
 * Unless required by applicable law or agreed to in writing, software         *
 * distributed under the License is distributed on an "AS IS" BASIS,           *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    *
 * See the License for the specific language governing permissions and         *
 * limitations under the License.                                              *
 *                                                                             *
 * --------------------------------------------------------------------------- *
 * *************************************************************************** *
 */

/*!
  \namespace ALGOR
  \brief Глобальний простір імен усього проекту
  \details Призначений для зберігання усього реалізованого функціоналу проекту.
  Краще не використовувати разом з std, інакше можуть виникнути конфлікти.
  \since v0.1.2.0 commit 2fa93b
  \example sort_global.cpp
  \example sort_test.cpp
  \example Algor_core.cpp
  \example Algor_printer.cpp
  \example Algor_exception.cpp
  \example Algor_random.cpp
  \example Algor_ArrayProcessing.cpp
 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                  ALGOR_CORE                                 *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

	/*!
	   \typedef ALGOR::byte1_t
	   \brief Аліас для char <em>(1 байт)</em>.
	   \details Зазвичай використовується для задання типу строк. Може зберігати
	   число від <b>0</b> до <b>255</b>, або від <b>-128</b> до <b>+127</b>.
	   \since v0.1.3.0 commit b50b4a
	   \note Якщо цей тип дійсно використовується для строк, то не забувайте
	   вказувати "*" (вказівник) перед назвою імені строки, так як цей тип
	   не замінює повністю char на string. Це лише звичайний аліас.
	 */
	 
	/*!
	   \typedef ALGOR::byte2_t
	   \brief Аліас для short <em>(2 байти)</em>.
	   \details Зазвичай використовується при зберіганні коротких чисел
	   від <b>0</b> до <b>65'535</b>, або від <b>-32'768</b> до <b>+32'767</b>.
	   \since v0.1.3.0 commit b50b4a
	 */

	/*!
	   \typedef ALGOR::byte4_t
	   \brief Аліас для long <em>(4 байти)</em>.
	   \details Зазвичай використовується при зберіганні чисел. Може
	   зберігати від <b>0</b> до <b>4'294'967'295</b>, або від <b>-2'147'483'648</b>
	   до <b>+2'147'483'647</b>.
	   \since v0.1.3.0 commit b50b4a
	   \note Також ним можна повноцінно замінити тип int, так як він теж
	   розрахований на 4 байти. Але якщо програму запустити на комп'ютері
	   з процесором intel i386 чи більш ранішим, то під int буде виділятися усього
	   2 байти і на тих процесорах int є аліасом для short. Через таке розпливчате
	   поняття типу int він ніде у бібліотеці не використовується, а використовуються
	   чіткі типи типу short чи long.
	 */

	/*!
	   \typedef ALGOR::byte8_t
	   \brief Аліас для long long <em>(8 байтів)</em>.
	   \details Є розширенням типу long у два рази і розрахований під числа від <b>0</b>
	   до <b>18'446'744'073'709'551'615</b>, або від <b>-9'223'372'036'854'775'808</b>
	   до <b>+9'223'372'036'854'775'807</b>.
	   \since v0.1.3.0 commit b50b4a
	 */

	/*!
	   \typedef ALGOR::sbit8_t
	   \brief Аліас для signed char <em>(1 байт)</em>.
	   \details Аналогічно звичайному char, але може приймати значення тільки
	   від <b>-128</b> до <b>+127</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::sbit16_t
	   \brief Аліас для signed short <em>(2 байти)</em>.
	   \details Аналогічно звичайному short, але може приймати значення тільки
	   від <b>-32'768</b> до <b>+32'767</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::sbit32_t
	   \brief Аліас для signed long <em>(4 байти)</em>.
	   \details Аналогічно звичайному long, але може приймати значення тільки
	   від <b>-2'147'483'648</b> до <b>+2'147'483'647</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::sbit64_t
	   \brief Аліас для signed long long <em>(8 байтів)</em>.
	   \details Аналогічно звичайному long long, але може приймати значення тільки
	   від <b>-9'223'372'036'854'775'808</b> до <b>+9'223'372'036'854'775'807</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::ubit8_t
	   \brief Аліас для unsigned char <em>(1 байт)</em>.
	   \details Аналогічно звичайному char і на відміну від signed char може
	   приймати значення тільки від <b>0</b> до <b>255</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::ubit16_t
	   \brief Аліас для unsigned short <em>(2 байти)</em>.
	   \details Аналогічно звичайному short і на відміну від signed short може
	   приймати значення тільки від <b>0</b> до <b>65'535</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::ubit32_t
	   \brief Аліас для unsigned long <em>(4 байти)</em>.
	   \details Аналогічно звичайному long і на відміну від signed long може
	   приймати значення тільки від <b>0</b> до <b>4'294'967'295</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::ubit64_t
	   \brief Аліас для unsigned long long <em>(8 байтів)</em>.
	   \details Аналогічно звичайному long long і на відміну від signed long long
	   може приймати значення тільки від <b>0</b> до <b>18'446'744'073'709'551'615</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::fbit32_t
	   \brief Аліас для float <em>(4 байти)</em>.
	   \details На відміну від всіх попередніх типів, що можуть зберігати тільки
	   цілі числа, тип \a float може зберігати числа з плаваючою комою. У
	   комірку можна записати як додатні, так і від'ємні числа. Можливий діапазон
	   зберігаємих чисел від <b>+/-3.4E-38</b> до <b>3.4E+38</b>.
	   \since v0.1.2.0 commit 1981d6
	 */

	/*!
	   \typedef ALGOR::fbit64_t
	   \brief Аліас для double <em>(8 байтів)</em>.
	   \details Розширює тип \a float, збільшуючи точність та розмір у два рази.
	   Можливий діапазон зберігаємих чисел від <b>+/-1.7E-308</b> до <b>1.7E+308</b>.
	   \since v0.1.2.0 commit 1981d6
	 */

	/*!
	   \typedef ALGOR::fbit128_t
	   \brief Аліас для long double <em>(16 байт)</em>.
	   \details Розширює тип \a double, збільшуючи точність та розмір іще у два
	   рази.
	   \since v0.1.3.0 commit b6349a
	 */

	/*!
	   \typedef ALGOR::asize_t
	   \brief Псевдонім для визначення типу <em>"розмір массиву"</em>.
	   \details Зазвичай цей тип використовується, коли треба вказати розмір масиву
	   чи позицію у масиві. Так як нумерація починається з 0 і не існує від'ємних
	   розмірів масивів чи номерів позицій, можна поточнити тип з <a>int</a> до
	   <a>unsigned int</a>. До того ж не завжди вистачає <b>65'535</b> комірок масиву.
	   Іноді потрібно більше, наприклад, мільйон чи мільярд. Більше мільярда нема
	   сенсу створювати структури даних тому ідеальним вибором серед <a>short</a>,
	   <a>long</a> та <a>long long</a> є <a>long</a>. Саме тому <a>asize_t</a> є
	   аліасом до <a>ubit32_t</a>.
	   \since v0.1.0.0 commit 89658e
	 */

	/*!
	   \typedef ALGOR::memcell_t
	   \brief Псевдонім для обчислюваної <em>комірки пам'яті</em>.
	   \details використовується тільки у функції \a getMemoryCell(). Є службовим типом
	   і замість нього краще використовувати \a ubit64_t.
	   \since v0.1.1.3 commit b4cdc9
	 */

	/*!
	   \fn ALGOR::swap(type_value &, type_value &)
	   \brief Міняє місцями два елементи
	   \details Функція приймає два значення, які треба замінити місцями. Після
	   виконання функції перша комірка пам'яті буде зберігати друге значення, а
	   друга - перше. Для виконання алгоритму використовується додаткова
	   комірка пам'яті.
	   \tparam type_value Тип елементів, що міняються місцями
	   \param[in, out] firstNumber Перший елемент для заміни
	   \param[in, out] secondNumber Другий елемент для заміни
	   \since v0.0.0.1
	   \test
	   \snippet Algor_core.cpp swap
	 */

	/*!
	   \fn ALGOR::minimum(type_value, type_value)
	   \brief Шукає найменше значення з двух наданих
	   \details Функція приймає два значення і порівнює їх. Якщо перше
	   число виявится меншим за друге - функція повертає перше число, інакше -
	   друге.
	   \tparam type_value Тип елементів, з яких вибирається найменше значення
	   \param[in] firstNumber Перше значення на вибірку
	   \param[in] secondNumber Друге значення на вибірку
	   \since v0.1.1.4 commit 090b06
	   \return найменше значення з двух наданих
	   \test
	   \snippet Algor_core.cpp minimum
	 */

	/*!
	   \fn ALGOR::maximum(type_value, type_value)
	   \brief Шукає найбільше значення з двух наданих
	   \details Функція приймає два значення і порівнює їх. Якщо перше
	   число виявится більшим за друге - функція повертає перше число, інакше -
	   друге.
	   \tparam type_value Тип елементів, з яких вибирається найбільше значення
	   \param[in] firstNumber Перше значення на вибірку
	   \param[in] secondNumber Друге значення на вибірку
	   \since v0.1.1.4 commit 090b06
	   \return найбільше значення з двух наданих
	   \test
	   \snippet Algor_core.cpp maximum
	 */

	/*!
	   \fn ALGOR::getMemoryCell(memcell_t, memcell_t)
	   \brief Повертає випадкове число; аналог time(NULL)
	   \details Цей метод виділяє пам'ять під 10 комірок пам'яті. Куди саме система
	   виділить пам'ять передгадати неможливо, а також неможливо передгадати, яка
	   програма і які данні раніше сюди записувала, тому це самий реальний генератор
	   випадкович чисел. Поки генерація масивів не була доведена до ідеалу, але як
	   генераточ великого числа замість time(NULL) цілком реально використати. Із
	   десяти випадкових чисел функція розраховує число, яке треба повернути.
	   \param[in] right_adjust Правий здвиг
	   \param[in] left_adjust Лівий здвиг
	   \since v0.1.1.3 commit b4cdc9
	   \remark Функції можна задати бітовий здвиг. Якщо функція використовується
	   замість time(NULL), а результат передається у іншу функцію, що приймає тільки
	   чотири-байтове значення, можна задати правий здвиг на 32 біти (4 байти) і
	   тоді функція поверне 4 старших байти.
	   \retval cell - розраховане випадкове число
	   \test
	   \snippet Algor_core.cpp mem
	 */

	/*!
	   \interface ALGOR::Printer
	   \brief Printer-інтерфейс, призначений для реалізації функціоналу виводу
	   інформації
	   \details Це є інтерфейс, що складається лише з одного віртуального методу, який
	   призначений для виводу інформації. Так як цей проект є унікальним у тому сенсі,
	   що не використовується жодна інша бібліотека (навіть стандартна) і автор
	   власноруч пише власну реалізацію алгоритмів - тому неможливо використати
	   клас iostream, через що неможлива реалізація принтеру. Автору потрібно буде з
	   початку написати власний клас вводу-виводу, а в умовах популярності графічних
	   інтерфейсів це не є оптимальним та актуальним. Краще програмісту самому дати
	   реалізувавти ввод-вивід. До того ж такий метод є універсальним: його можна
	   використовувати й у консольних програмах, й у графічних. Якби я намагався
	   власноруч написати реалізацію, вона була б спеціалізованою чи під консоль, чи
	   під графіку. Саме це мене підштовхнуло написати саме інтрерфейс, а не клас.
	   \since v0.1.2.0 commit 2fa93b
	   \remark
	   Раджу використовувати наступну реалізацію для консольної програми:
	   \test
	   \snippet Algor_printer.cpp printer
	   Цей клас зберігає не матрицю, а вказівник на вказівник на структуру масиву.
	   Тому достатньо один раз передати у клас вказівник на структуру і все. Далі
	   можна просто міняти вказівники на інші структури з іншими масивами і не
	   треба їх заново передавати у цей клас. Він сам буде відстежувати, який
	   вказівник зберігається у вказівнику на структуру.
	 */

		/*!
		   \fn ALGOR::Printer::print()
		   \brief Метод для виводу інформації
		   \since v0.1.2.0 commit 2fa93b
		   \paragraph Приклад
		   \test
		   \snippet Algor_printer.cpp print
		 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                               ALGOR_EXCEPTION                               *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

	/*!
	  \namespace ALGOR::EXCEPTION_SET
	  \brief Простір імен, що реалізовує виключення
	  \details Простір імен являє собою набір класів, які використовуються при киданні
	  виключень, так як зберігають необхідну інформацію про випадок, що стався. Головний
	  клас \a Exception являє собою каркас винятка, який можна успадкувати для
	  полегшення роботи з винятками. Можна дати додаткову інформацію до вже реалізованих
	  класів-нащадків, а можна створити власні класи-нащадки.
	  \since v0.1.3.0 commit 2cdff0
	 */

		/*!
		   \class ALGOR::EXCEPTION_SET::Exception
		   \brief Клас-каркас для роботи з винятками
		   \details Клас, що зберігає данні про виняток (номер винятка, деталі та
		   пояснення). Щоб створити об'єкт винятку достатньо переадти необхідні данні
		   конструктору, а для отримання інформації про виняток треба його перехопити
		   і використати метод, що повертає необхідні данні.
		   \since v0.1.1.0 commit c62e85
		   \test
		   \snippet Algor_exception.cpp exception code details explanation class
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::Exception(ubit16_t, const byte1_t *, const byte1_t *)
			   \brief Розширений конструктор класу винятків
			   \details Конструктор, що приймає розширену кількість данних, а саме код
			   винятку, деталі винятку, та пояснення до деталей, що не завжди буває
			   необхідним.
			   \param[in] CODE Код Exception
			   \param[in] DETAILS Деталі Exception
			   \param[in] EXPLANATION Пояснення Exception
			   \since v0.1.3.0 commit 2c6408
			   \remark Цей конструктор є розширеним так як дозволяє успадкованим класам
			   надати пояснення до винятку, коли це необхідно, що робить цей клас
			   більш універсальним.
			   \test
			   \snippet Algor_exception.cpp exception code details explanation
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::Exception(ubit16_t, const byte1_t *)
			   \brief Стандартний конструктор класу винятків
			   \details Конструктор, що приймає базову кількість данних про виняток.
			   Зазвичай номеру та деталей помилки буває достатньо.
			   \param[in] CODE Код Exception
			   \param[in] DETAILS Деталі Exception
			   \since v0.1.1.0 commit c62e85
			   \test
			   \snippet Algor_exception.cpp exception code details
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::Exception(ubit16_t)
			   \brief Скорочений кодовий конструктор класу винятків
			   \details Конструктор, що приймає скорочену кількість данних про
			   виняток. Єдині данні, що зберігаються у об'єкті винятку, це номер
			   винятку.
			   \param[in] CODE Код Exception
			   \since v0.1.1.0 commit c62e85
			   \test
			   \snippet Algor_exception.cpp exception code
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::Exception(const byte1_t *)
			   \brief Скорочений детальний конструктор класу винятків
			   \details Конструктор, що приймає скорочену кількість данних про
			   виняток. Єдині данні, що зберігаються у об'єкті винятку, це деталі
			   винятку.
			   \param[in] DETAILS Деталі Exception
			   \since v0.1.1.0 commit c62e85
			   \test
			   \snippet Algor_exception.cpp exception details
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::code()
			   \brief Метод, що повідомляє номер винятку
			   \details Повертає номер винятку, що зберігається в об'єкті.
			   \since v0.1.1.0 commit c62e85
			   \retval CODE - номер винятку
			   \test
			   \snippet Algor_exception.cpp exception catch code
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::what()
			   \brief Метод, що повідомляє деталі винятку
			   \details Повертає деталі винятку, що зберігаються в об'єкті.
			   \since v0.1.1.0 commit c62e85
			   \retval DETAILS - деталі винятку
			   \test
			   \snippet Algor_exception.cpp exception catch details
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::why()
			   \brief Метод, що дає пояснення винятку
			   \details Повертає пояснення винятку, що зберігається в об'єкті.
			   \since v0.1.3.0 commit 2c6408
			   \retval EXPLANATION - пояснення винятку
			   \test
			   \snippet Algor_exception.cpp exception catch explanation
			 */

			/*!
			   \var ALGOR::EXCEPTION_SET::Exception::CODE
			   \brief Номер винятку
			   \since v0.1.1.0 commit c62e85
			 */

			/*!
			   \var ALGOR::EXCEPTION_SET::Exception::DETAILS
			   \brief Деталі винятку
			   \since v0.1.1.0 commit c62e85
			 */

			/*!
			   \var ALGOR::EXCEPTION_SET::Exception::EXPLANATION
			   \brief Пояснення винятку
			   \since v0.1.3.0 commit 2c6408
			 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep55
		   \brief Повідомлення для memory_overflow
		   \since v0.1.3.0 commit d66e53
		   \paragraph Текст повідомлення
		   <em>"Комірка пам'яті, в якій зберігається розмір обсягу даних, більше
		   не може зберігати більше. Ця помилка може виникнути у випадках, коли
		   в комірку, яка може зберігати змінну 0xffffffff, потрібно записати
		   більше значення, тобто більше 4 байт, оскільки клітинка зберігання
		   даних займає 4 байти"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep101
		   \brief Повідомлення для division_by_zero
		   \since v0.1.3.0 commit d66e53
		   \paragraph Текст повідомлення
		   <em>"Відбулося ділення на нуль - невизначений результат виконання
		   програми"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep254
		   \brief Повідомлення для position_failure
		   \since v0.1.3.0 commit d66e53
		   \paragraph Текст повідомлення
		   <em>"Помилка позиції - позиція відсутня в масиві"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep255
		   \brief Повідомлення для value_failure
		   \since v0.1.3.0 commit d66e53
		   \paragraph Текст повідомлення
		   <em>"Помилка значення - значення відсутнє в масиві"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep256
		   \brief Повідомлення для size_failure
		   \since v0.1.3.0 commit d66e53
		   \paragraph Текст повідомлення
		   <em>"Помилка розміру - помилка зміни розміру; наприклад, це може
		   статися, коли розміри збігаються, коли розмір масиву змінюється, або
		   новий розмір більше/менше за межі розмірів"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep400
		   \brief Повідомлення для void_data
		   \since v0.1.3.0 commit d66e53
		   \paragraph Текст повідомлення
		   <em>"Отримано порожню структуру даних"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep404
		   \brief Повідомлення для not_found
		   \since v0.1.3.0 commit d66e53
		   \paragraph Текст повідомлення
		   <em>"Помилка пошуку - елемент не знайдено"</em>
		 */

		/*!
		   \class ALGOR::EXCEPTION_SET::memory_overflow
		   \brief Клас-виняток \a "memory_overflow"
		   \details Базовий виняток \a memory_overflow (переповнення пам'яті).
		   Використовує повідомлення EXCEPTION_SET::excep55 та має номер \a 55.
		   \since v0.1.1.0 commit bce6b6
		   \remark Де-які методи при киданні винятку \a 55 можуть давати пояснення.
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::memory_overflow::memory_overflow()
			   \brief Виняток memory_overflow
			   \details Конструктор об'єкту, що використовується, як виняток
			   memory_overflow. До каркасу передаються код виключення та деталі.
			   \since v0.1.1.0 commit bce6b6
			   \test
			   \snippet Algor_exception.cpp exception memory_overflow
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::memory_overflow::memory_overflow(const byte1_t *)
			   \brief Виняток memory_overflow з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   memory_overflow. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \test
			   \snippet Algor_exception.cpp exception memory_overflow explanation
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::division_by_zero
		   \brief Клас-виняток \a "division_by_zero"
		   \details Базовий виняток \a division_by_zero (ділення на нуль).
		   Використовує повідомлення EXCEPTION_SET::excep101 та має номер \a 101.
		   \since v0.1.2.0 commit d74cc1
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::division_by_zero::division_by_zero()
			   \brief Виняток division_by_zero
			   \details Конструктор об'єкту, що використовується, як виняток
			   division_by_zero. До каркасу передаються код виключення та деталі.
			   \since v0.1.2.0 commit d74cc1
			   \test
			   \snippet Algor_exception.cpp exception division_by_zero
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::division_by_zero::division_by_zero(const byte1_t *)
			   \brief Виняток division_by_zero з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   division_by_zero. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \test
			   \snippet Algor_exception.cpp exception division_by_zero explanation
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::position_failure
		   \brief Клас-виняток \a "position_failure"
		   \details Базовий виняток \a position_failure (збій положення).
		   Використовує повідомлення EXCEPTION_SET::excep254 та має номер \a 254.
		   \since v0.1.1.0 commit 8bbf75
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::position_failure::position_failure()
			   \brief Виняток position_failure
			   \details Конструктор об'єкту, що використовується, як виняток
			   position_failure. До каркасу передаються код виключення та деталі.
			   \since v0.1.1.0 commit 8bbf75
			   \test
			   \snippet Algor_exception.cpp exception position_failure
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::position_failure::position_failure(const byte1_t *)
			   \brief Виняток position_failure з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   position_failure. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \test
			   \snippet Algor_exception.cpp exception position_failure explanation
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::value_failure
		   \brief Клас-виняток \a "value_failure"
		   \details Базовий виняток \a value_failure (збій значення).
		   Використовує повідомлення EXCEPTION_SET::excep255 та має номер \a 255.
		   \since v0.1.1.0 commit 8bbf75
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::value_failure::value_failure()
			   \brief Виняток value_failure
			   \details Конструктор об'єкту, що використовується, як виняток
			   value_failure. До каркасу передаються код виключення та деталі.
			   \since v0.1.1.0 commit 8bbf75
			   \test
			   \snippet Algor_exception.cpp exception value_failure
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::value_failure::value_failure(const byte1_t *)
			   \brief Виняток value_failure з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   value_failure. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \test
			   \snippet Algor_exception.cpp exception value_failure explanation
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::size_failure
		   \brief Клас-виняток \a "size_failure"
		   \details Базовий виняток \a size_failure (збій розміру).
		   Використовує повідомлення EXCEPTION_SET::excep256 та має номер \a 256.
		   \since v0.1.3.0 commit 2c6408
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::size_failure::size_failure()
			   \brief Виняток size_failure
			   \details Конструктор об'єкту, що використовується, як виняток
			   size_failure. До каркасу передаються код виключення та деталі.
			   \since v0.1.3.0 commit 2c6408
			   \test
			   \snippet Algor_exception.cpp exception size_failure
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::size_failure::size_failure(const byte1_t *)
			   \brief Виняток size_failure з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   size_failure. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \test
			   \snippet Algor_exception.cpp exception size_failure explanation
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::void_data
		   \brief Клас-виняток \a "void_data"
		   \details Базовий виняток \a void_data (недійсні дані).
		   Використовує повідомлення EXCEPTION_SET::excep400 та має номер \a 400.
		   \since v0.1.1.0 commit c62e85
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::void_data::void_data()
			   \brief Виняток void_data
			   \details Конструктор об'єкту, що використовується, як виняток
			   void_data. До каркасу передаються код виключення та деталі.
			   \since v0.1.1.0 commit c62e85
			   \test
			   \snippet Algor_exception.cpp exception void_data
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::void_data::void_data(const byte1_t *)
			   \brief Виняток void_data з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   void_data. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \test
			   \snippet Algor_exception.cpp exception void_data explanation
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::not_found
		   \brief Клас-виняток \a "not_found"
		   \details Базовий виняток \a not_found (не знайдено).
		   Використовує повідомлення EXCEPTION_SET::excep404 та має номер \a 404.
		   \since v0.1.1.0 commit c62e85
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::not_found::not_found()
			   \brief Виняток not_found
			   \details Конструктор об'єкту, що використовується, як виняток
			   not_found. До каркасу передаються код виключення та деталі.
			   \since v0.1.1.0 commit c62e85
			   \test
			   \snippet Algor_exception.cpp exception not_found
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::not_found::not_found(const byte1_t *)
			   \brief Виняток not_found з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   not_found. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \test
			   \snippet Algor_exception.cpp exception not_found explanation
			 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                 ALGOR_RANDOM                                *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

	/*!
	  \namespace ALGOR::RANDOM
	  \brief Простір імен, що реалізовує ГПВЧ
	  \details Простір імен являє собою набір класів, які використовуються при
	  Генерації ПсевдоВипадкових Чисел (ГПВЧ). Класи є реалізаціями математичних
	  моделей. Зазвичай використовуються при генерації структур даних, таких як
	  масиви тощо.
	  \since v0.1.3.0 commit d66e53
	 */

		/*!
		   \class ALGOR::RANDOM::LCM
		   \brief ГПВЧ Лінійний Конґруентний Метод
		   \details Один з найпростіших ГПВЧ. Працює за принципом розрахунку
		   наступного числа. Представляється формулою
		   \f[x_n = (a * x_{n-1} + c)mod(m)\f], де \f$a, c, m\f$ - константні
		   коефіціенти.
		   \since v0.1.3.0 commit ca0704
		   \remark LCM = LinearCongruentMethod
		   \paragraph Ресурси
		   Source: https://en.wikipedia.org/wiki/Linear_congruential_generator\n
		   Paragraph: Parameters in common use\n
		   Table row: MMIX by Donald Knuth\n
		   \test
		   \snippet Algor_random.cpp LCM class
		 */

			/*!
			   \fn ALGOR::RANDOM::LCM::LCM(memcell_t)
			   \brief Конструктор класу, що приймає сі́м'я
			   \details Конструктор, що приймає сі́м'я ГПВЧ, що є першим числом
			   послідовності, що генерується (\f$x_0\f$). Являє собою аналог
			   стандартної функції \a srand().
			   \param[in] seed
			   \since v0.1.3.0 commit ca0704
			   \test
			   \snippet Algor_random.cpp LCM srand
			 */

			/*!
			   \fn ALGOR::RANDOM::LCM::rand()
			   \brief Метод генерації псевдовипадкового числа
			   \details Алгоритм, що генерує (\a розраховує) наступне число
			   послідовності.
			   \since v0.1.3.0 commit ca0704
			   \retval seed - наступне число послідновності \f$x_n\f$
			   \test
			   \snippet Algor_random.cpp LCM rand
			 */

			/*!
			   \var ALGOR::RANDOM::LCM::a
			   \brief Перше константне число \f$a\f$
			   \details Константа \f$a\f$ = 6'364'136'223'846'793'005.
			   \since v0.1.3.0 commit ca0704
			 */

			/*!
			   \var ALGOR::RANDOM::LCM::c
			   \brief Перше константне число \f$c\f$
			   \details Константа \f$c\f$ = 1'442'695'040'888'963'407.
			   \since v0.1.3.0 commit ca0704
			 */

			/*!
			   \var ALGOR::RANDOM::LCM::m
			   \brief Перше константне число \f$m\f$
			   \details Константа \f$m\f$ = 18'446'744'073'709'551'615.
			   \since v0.1.3.0 commit ca0704
			 */

			/*!
			   \var ALGOR::RANDOM::LCM::seed
			   \brief Сі́м'я послідовності \f$x_0\f$
			   \details Число, що задає початок послідовності, що генерується.
			   \since v0.1.3.0 commit ca0704
			 */

		/*!
		   \class ALGOR::RANDOM::RC4
		   \brief Простий криптостійкий генератор
		   \details RC4 — потоковий шифр, розроблений Роном Рівестом
		   (анг. Ron Rivest) у 1987 році.
		   \since v0.1.0.0 commit 88415c
		   \note Може генерувати значення лише у діапазоні 0-255 (1 байт).
		   \deprecated На даному етапі розробка даного ГВЧ заморожена. Алгоритм
		   застарів. З часом можливе його повне видалення, чи повна модернізація,
		   чому не радиться його використовувати.
		   \paragraph Ресурси
		   Source: https://www.youtube.com/watch?v=PQlZI-QoM2A\n
		   \test
		   \snippet Algor_random.cpp RC4 class
		*/

			/*!
			   \fn ALGOR::RANDOM::RC4::crypto_srand(const byte1_t *, byte4_t)
			   \brief Встановлює ключ генерації
			   \details Приймає ключ і розраховує з нього ключ генерації
			   \param[in] key Ключ, що встановлюється
			   \param[in] ksize Розмір ключа
			   \since v0.1.0.0 commit 88415c
			   \test
			   \snippet Algor_random.cpp RC4 srand
			 */

			/*!
			   \fn ALGOR::RANDOM::RC4::crypto_rand(byte1_t *, byte4_t)
			   \brief Генерує значення
			   \details Генерує масив вихідних зашифрованих значень, які можна
			   використовувати, як згенеровані ГВЧ.
			   \param[out] output Генерує масив вихідних елементів
			   \param size Розмір масиву вихідних елементів
			   \since v0.1.0.0 commit 88415c
			   \test
			   \snippet Algor_random.cpp RC4 rand
			 */

			/*!
			   \var ALGOR::RANDOM::RC4::Sbox
			   \brief Ключ генерації
			   \since v0.1.0.0 commit 88415c
			 */

		/*!
		   \class ALGOR::RANDOM::MersenneTwister
		   \brief Складний ГПВЧ, що базується на властивостях простих чисел Мерсенна
		   \details Вихор Мерсенна — ГПВЧ, розроблений у 1997 році японськими
		   вченими Макото Мацумото та Такудзі Нісімурою. Вихор Мерсенна ґрунтується
		   на властивостях простих чисел Мерсенна та забезпечує швидке генерування
		   високоякісних за критерієм випадковості псевдовипадкових чисел.
		   \since v0.1.0.0 commit 88415c
		   \deprecated На даному етапі розробка даного ГВЧ заморожена. Нехай
		   він і краще за Лінійні ГПВЧ, його ще не доведено до відлагодженого стану.
		   Його ще й досі складно використовувати. У майбутньому можлива повна
		   зміна сигнатур методів у класі. Чи його повне видалення.
		   \paragraph Ресурси
		   Source: https://www.agner.org/random/\n
		   \test
		   \snippet Algor_random.cpp MT class
		 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::MersenneTwister(byte4_t)
			   \brief Конструктор класу ГПВЧ Вихор Марсенна (встановлює сі́м'я)
			   \details Встановлює сі́м'я та проводить ініціалізацію послідовності,
			   що буде генеруватися.
			   \param[in] seed Сі́м'я генерації
			   \since v0.1.0.0 commit 88415c
			   \test
			   \snippet Algor_random.cpp MT srand
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::RandomInit(byte4_t)
			   \brief Ініціалізація ГПВЧ
			   \details Використовується при перевстановленні семені ГПВЧ.
			   \param[in] seed Сі́м'я генерації
			   \since v0.1.0.0 commit 88415c
			   \test
			   \snippet Algor_random.cpp MT reinit
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::rand()
			   \brief Метод генеації даних на усьому можливому діапазоні
			   \details Генерує числа на увесь можливий діапазон змінної. Цей метод
			   спеціально було створено під сумісність з функцією тестування ГПВЧ.
			   \since v0.1.3.0 commit ca0704
			   \warning Цей метод було написано лише для функції тестування ГПВЧ. Не
			   використовуйте його, якщо у вас є обмеження на число, що має бути
			   згенероване. Для цього використовуйте метод
			   MersenneTwister::IRandom, що спеціально для цього й створювався.
			   \warning А також, якщо Вам потрібно згенерувати число на усьому
			   діапазоні, то краще використати MersenneTwister::BRandom, щоб уникнути
			   додаткових розрахунків.
			   \deprecated Буде видалено після завершення тестування ГПВЧ
			   \return згенероване число
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::IRandom(byte4_t, byte4_t)
			   \brief Метод генерація числа у заданому діапазоні
			   \details Генерує число у заданому діапазоні.
			   \param[in] min Мінімальне число діапазону
			   \param[in] max Максимальне число діапазону
			   \since v0.1.0.0 commit 88415c
			   \return згенероване число у заданому діапазоні
			   \test
			   \snippet Algor_random.cpp MT rand int
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::IRandomX(byte4_t, byte4_t)
			   \brief Більш точніший метод генерація числа у заданому діапазоні
			   \details Є аналогом методу MersenneTwister::IRandom, що генерує
			   число за складнішим алгоритмом, а саме число є більш точнішим.
			   \param[in] min Мінімальне число діапазону
			   \param[in] max Максимальне число діапазону
			   \since v0.1.0.0 commit 88415c
			   \return точне згенероване число у заданому діапазоні
			   \test
			   \snippet Algor_random.cpp MT rand int extend
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::Random()
			   \brief Метод генеріції числа з плаваючою комою
			   \details Генерує числа з плаваючою комою
			   \since v0.1.0.0 commit 88415c
			   \warning Цей метод генерує числа від 0 до 1, тобто всі
			   згенеровані числа будуть меншими від одиниці
			   \return число з плаваючою комою
			   \test
			   \snippet Algor_random.cpp MT rand double
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::BRandom()
			   \brief Метод генерації випадкових бітів
			   \details Генерує випадкові біти у змінній з чотирьох байт, що дозволяє
			   згенерувати 32-бітове число на всьому діапазоні.
			   \since v0.1.0.0 commit 88415c
			   \note Може слугувати аналогом методу MersenneTwister::rand, але той
			   метод є надстройкою над MersenneTwister::IRandom для функції тестування
			   ГПВЧ, що викликає додаткові розрахунки та витрати ресурсів. Якщо
			   потрібно відразу згенерувати якесь число на усьому діапазоні, то краще
			   обирати цей метод.
			   \return згенероване число на всьому діапазоні
			   \test
			   \snippet Algor_random.cpp MT rand bits
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::Init0(byte4_t)
			   \brief Базова процедура ініціалізації
			   \param[in] seed Сі́м'я генерації
			   \since v0.1.0.0 commit 88415c
			 */

			/*!
			   \var ALGOR::RANDOM::MersenneTwister::mersenne_twister
			   \brief Вектор стану
			   \since v0.1.0.0 commit 88415c
			 */

			/*!
			   \var ALGOR::RANDOM::MersenneTwister::mersenne_twister_index
			   \brief Індекс у векторі стану (MersenneTwister::mersenne_twister)
			   \since v0.1.0.0 commit 88415c
			 */

			/*!
			   \var ALGOR::RANDOM::MersenneTwister::LastInterval
			   \brief Довжина останнього інтервалу для MersenneTwister::IRandomX
			   \since v0.1.0.0 commit 88415c
			 */

			/*!
			   \var ALGOR::RANDOM::MersenneTwister::RejectionLimit
			   \brief Ліміт відхилень, який використовує MersenneTwister::IRandomX
			   \since v0.1.0.0 commit 88415c
			 */

		/*!
		   \fn ALGOR::RANDOM::test_random_on_Pearsons_coefficient(ubit32_t, ubit32_t)
		   \brief Функція тестування ГПВЧ на рівномірність
		   \details Тестує ГПВЧ на рівномірність генерації чисел, використовуючи
		   коефіціент узгодженості Пірсона.
		   \tparam Generator Клас алгоритму ГПВЧ, що потрібно протестувати.
		   \param[in] left_limit Мінімальне число діапазону генерації
		   при тестуванні
		   \param[in] right_limit Максимальне число діапазону генерації
		   при тестуванні
		   \since v0.1.3.0 commit ca0704
		   \warning ГВЧ RANDOM::RC4 поки не можна протестувати, так як його не
		   підготовлено до використання данною функцією тестування, та й сама
		   функція не компілюється під цей алгоритм.
		   \return коефіціент узгодженості Пірсона
		   \test
		   \snippet Algor_random.cpp random test
		   \remark Як можна побачити з прикладу, RANDOM::LCM генерує
		   числа більш рівномірно. Однак це не значить, що він є кращим... Як вже
		   було сказано, ГПВЧ Вихор Марсена є швидшим <del>(хоча й використовує
		   набагато більше операцій та розрахунків)</del> та якіснішим. А отримані
		   результати є лише випадковістю. Інколи краще генерує RANDOM::LCM, а
		   інколи RANDOM::MersenneTwister, через що можна зробити висновок, що вони
		   однаково якісно генерують числа <del>(чи може просто добре підібрані
		   коефіціенти для RANDOM::LCM)</del>. Для функції генерації
		   ALGOR::generate_struct структури масиву ALGOR::Array все ж таки було
		   обрано RANDOM::LCM, так як він набагато легший у реалізації та
		   розумінні, а працює так само якісно, як і RANDOM::MersenneTwister.
		 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                 ALGOR_ARRAY                                 *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

	/*!
	   \class ALGOR::ArrayProcessing
	   \brief Класс базових функцій для роботи з масивами
	   \details Клас із базовими функціями обробки масивів. Вони призначені, як
	   для зміни масиву, так і для визначення його певних характеристик. Функції
	   розраховані під використання стандартних С++ масивів, без поглиблення в
	   абстракції, типу використання структур чи класів (на те вони і є базовими).
	   \tparam type_array Тип елементів, які зберігає масив, який потрібно обробити
	   \since v0.1.2.0 commit 1981d6
	   \remark У вас можуть виникнути питання щодо версіонування. Тема роз'яснена
	   на наступній сторінці \ref ArrayBaseHistory.md
	   \image html ArrayProcessingFamilyTree.png
	   \image latex ArrayProcessingFamilyTree.png "My application" width=10cm
	   \note Не обов'язково створювати структуру і з неї передавати данні до функцій.
	   Вони навмисно були розроблені, щоб вони приймали не структуру, а саме сам
	   масив
	   \warning Клас компілюється лише наступних типів: ALGOR::byte8_t, ALGOR::ubit64_t,
	   ALGOR::fbit64_t, ALGOR::fbit128_t, ALGOR::asize_t. Отже, функції працюють
	   лише з тими масивами, тип яких є long long, unsigned long long, double, long
	   double, unsigned int!!!
	 */

		/*!
		   \fn ALGOR::ArrayProcessing::minimum(const type_array *, const asize_t &)
		   \brief Шукає мінімальний елемент у масиві методом перебору
		   \details Методом перебору по всьому масиву функція шукає та повертає
		   найменше значення у масиві.
		   \param[in] Array Масив, у якому потрібно знайти мінімальний елемент
		   \param[in] array_size Розмір цього масиву
		   \since v0.0.0.1
		   \warning Функція працює не з усіма типами. Читай ALGOR::ArrayProcessing
		   \warning Ця функція не робить перевірку, чи є  масив відсортованим, а тому
		   не є ефективною. Краще перед виконанням цієї функції перевірити, чи є масив
		   відсортованим за допомогою функції ALGOR::ArrayProcessing::isOrderliness
		   \return значення найменшого елемента масиву
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing minimum
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::maximum(const type_array *, const asize_t &)
		   \brief Шукає максимальний елемент у масиві методом перебору
		   \details Методом перебору по всьому масиву функція шукає та повертає
		   найбільше значення у масиві.
		   \param[in] Array Масив, у якому потрібно знайти максимальний елемент
		   \param[in] array_size Розмір цього масиву
		   \since v0.0.0.1
		   \warning Функція працює не з усіма типами. Читай ALGOR::ArrayProcessing
		   \warning Ця функція не робить перевірку, чи є  масив відсортованим, а тому
		   не є ефективною. Краще перед виконанням цієї функції перевірити, чи є масив
		   відсортованим за допомогою функції ALGOR::ArrayProcessing::isOrderliness
		   \return значення найбільшого елемента масиву
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing maximum
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::isOrderliness(const type_array *, const asize_t &)
		   \brief Функція, що перевіряє, чи впорядковано масив
		   \details Функція перевіряє, чи є масив впорядкованим у порядку збільшення.
		   Якщо у якийсь момент функція фіксує, що поточний елемент ітерації більше
		   наступного, вона відразу повертає значення \a false, інакше - всі елементи
		   йдуть у порядку збільшення і функція повертає \a true.
		   \param[in] Array Масив, що перевіряється на відсортованість
		   \param[in] array_size Розмір цього масиву
		   \since v0.1.2.0 commit 2fa93b
		   \warning Ця функція перевіряє впорядкованість тільки у напрямку збільшення.
		   Якщо необхдіно перевірити впорядкованість порядку зменшення: на вхід функції
		   треба передати обернений масив, а цим функціоналом володіє тільки
		   ALGOR::ARRAYDATA::reverse
		   \return логічне значення, чи є масив впорядкованим (так чи ні)
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing isOrderliness
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::distance(type_array *, type_array *)
		   \brief Повертає відстань між вказівниками на два елементи масиву
		   \details Розраховує різницю між двома вказівниками, яка (різниця) являє
		   собою відстань між цими самими двома вказівниками.
		   \param[in] first Вказівник на перший вказаний елемент масиву
		   \param[in] last Вказівник на другий вказаний елемент масиву
		   \since v0.1.2.1 commit ffc19f
		   \return різницю між адресами вказівників
		   \paragraph Ресурси
		   Source: http://www.cplusplus.com/reference/iterator/distance/?kw=distance\n
		   \note Перевагами над стандартною функцією є те, що вона працює з об'єктами
		   класу ітератор (як можна побачити з прикладу на офіційній сторінці
		   документації), а данна функція працює просто із вказівниками, що
		   є легше та надійніше.
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing distance
		   \remark Дану функцію можна використовувати для знаходження розміру масива. Якщо
		   ви колись зберегли вказівник на останній елемент масиву, а сам розмір було
		   загублено <del>(я не знаю як ви могли це зробити)</del>, тоді ви можете
		   використати цей алгоритм, передавши вказівник на перший елемент масиву і
		   збережений вказівник на останній елемент масиву. Так як алгоритм
		   повертає різницю між адресами, то адреса цього самого останнього елемента
		   не буде порахована у розмір масиву, а тому розмір масиву становитиме на
		   одиницю більше повернутого значення:
		   \code{.cpp}
		   int size = 10; //The size that will be lost...
		   long long arr[size];
		   long long *last_element = &arr[9];
		   //...
		   //Lots and lots of code... You forgot where the size of the array is stored...
		   //...
		   //Use distance:
		   cout << "Size array is " << ArrayProcessing<long long>::distance(&arr[0], last_element) + 1 << "\n";
		   //or
		   cout << "Size array is " << ArrayProcessing<long long>::distance(&arr[0], last_element + 1) << "\n";
		   \endcode
		   Тут не важливо, чи збільшите ви підсумковий результат на одиницю, чи
		   посунете вказівник на одиницю. У другому випадку вказівник буде виходити
		   за межі масиву, але як вже було сказано, у результат нічого не потрапляє
		   ззовні зазначених адрес, а тому таким чином ви додасте іще один останній
		   елемент, який раніше не рахувався, і не більше того.
		   \remark Коли я тільки додав ці функції, я хотів перевести усі функції із
		   сигнатур {вказівник на масив; розмір масиву} на {перший елемент; останній
		   елемент} (як у ALGOR::ArrayProcessing::distance), але не задалося, так як передавати перший варіант легше. Самі
		   розсудіть:
		   \code{.cpp}
		   Array<long long> *arr = create_struct<long long>(10);
		   ArrayProcessing<long long>::minimum(arr->array, arr->array_size); //old variant {array pointer; array size}
		   \endcode
		   проти
		   \code{.cpp}
		   Array<long long> *arr = create_struct<long long>(10);
		   ArrayProcessing<long long>::minimum(&arr->array[0], &arr->array[arr->array_size - 1]); //new variant {first element; last element}
		   \endcode
		   Я б обрав {вказівник на масив; розмір масиву}.
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::lower_bound(type_array *, type_array *, const type_array &)
		   \brief Знаходить перше входження у заданому діапаоні заданого елемента
		   \details Функція не є рекурсивною. Але вона використовує вказівники, як
		   ітератори, розраховуючи їх аналогічно рекурсивному методу. Таким чином
		   функція є оптимізованою, завдяки переходу з рекурсії на ітерацію, а
		   великим плюсом є можливість задати певний діапазон, що можливо тільки з
		   двома функціями ALGOR::ArrayProcessing::lower_bound та
		   ALGOR::ArrayProcessing::upper_bound.
		   \param[in] first Вказівник на перший вказаний елемент масиву, що задає
		   початок діапазону масиву, де треба знайти заданий елемент
		   \param[in] last Вказівник на другий вказаний елемент масиву, що задає
		   кінець діапазону масиву, де треба знайти заданий елемент
		   \param[in] value Заданий елемент, який потрібно знайти
		   \since v0.1.2.1 commit ffc19f
		   \return вказівник на перше входження заданого елемента у заданому діапазоні
		   \warning Функція повертає лише вказівник на елемент, а не його значення.
		   \paragraph Ресурси
		   Source: http://www.cplusplus.com/reference/algorithm/lower_bound/\n
		   \note Перевагами над стандартною функцією є те, що вона працює з об'єктами
		   класу ітератор (як можна побачити з прикладу на офіційній сторінці
		   документації), а данна функція працює просто із вказівниками, що
		   є легше та надійніше.
		   \warning Функція працює ітераційно аж до останнього елементу і повертає
		   вказівник саме на нього, не перевіряючи чи є це той самий потрібний елемент.
		   Але таке відбувається тільки з тими масивами, у яких взагалі нема заданого
		   елемента. Тому ви власноруч маєте перевіряти, чи є там взагалі потрібний
		   елемент.
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing lower_bound
		   \remark Дану функцію разом із ALGOR::ArrayProcessing::distance можна
		   використати для реалізації бінарного пошуку:
		   ALGOR::ArrayProcessing::lower_bound повертає вказівник на знайдений
		   елемент, а ALGOR::ArrayProcessing::distance розраховує відстань від
		   початку масиву, що і буде відображати положення у масиві (його номер).
		   Саме такий метод використиовується у ALGOR::ARRAYDATA::binary_getPosition.
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::upper_bound(type_array *, type_array *, const type_array &)
		   \brief Знаходить перше входження у заданому діапазоні елемента, що є
		   наступним після заданого
		   \details Аналогічно ALGOR::ArrayProcessing::lower_bound, данна функція
		   повертає вказівник на перше входження наступного елемента, після заданого.
		   \param[in] first Вказівник на перший вказаний елемент масиву, що задає
		   початок діапазону масиву, де треба знайти заданий елемент
		   \param[in] last Вказівник на другий вказаний елемент масиву, що задає
		   кінець діапазону масиву, де треба знайти заданий елемент
		   \param[in] value Заданий елемент, після якого потрібно повернути вказівник
		   \since v0.1.2.1 commit d94012
		   \return вказівник на перше входження наступного елемента після заданого
		   у заданому діапазоні
		   \note У цілому, використання функції подібне до
		   ALGOR::ArrayProcessing::lower_bound.
		   \paragraph Ресурси
		   Source: http://www.cplusplus.com/reference/algorithm/upper_bound/\n
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing upper_bound
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::addElement(type_array *&, asize_t &, const type_array &, const asize_t)
		   \brief Додає певне значення до масиву у вказаній позиції
		   \details Функція додає задане значеннян у заданий масив із заданим
		   розміром на задану позицію. Функція працює на місці.
		   \remark Якщо задати і в якості розміру, і в якості позиції розмір
		   масиву, то елемент буде додано у кінець масиву, так як функція збільшує
		   розмір масиву перед тим, як почати додавати елемент, а тому на цей момент
		   старий розмір масиву буде лише вказувати на позицію нового останнього
		   елемента. Саме тому цю функцію легше всього використовувати замість
		   push_back().
		   \param[in, out] Array Масив, до якого додається елемент
		   \param[in] array_size Розмір цього масиву
		   \param[in] value Елемент, який потрібно додати до масиву
		   \param[in] position Позиція, у якій буде додано елемент
		   \since v0.0.1.0 commit e37003
		   \exception EXCEPTION_SET::memory_overflow
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing addElement
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::subtractElement(type_array *&, asize_t &, const asize_t)
		   \brief Видаляє елемент по вказаній позиції у масиві
		   \details Видаляє елемент по вказаній позиції з масиву. Схожий на
		   ALGOR::ArrayProcessing::addElement.
		   \param[in, out] Array Масив, у якому буде видалено елемент по позиції
		   \param[in] array_size Розмір цього масиву
		   \param[in] position Позиція, з якої буде видалено елемент
		   \since v0.1.0.0 commit 37cab7
		   \warning Не забувайте, що нумерація починається з 0!
		   \exception EXCEPTION_SET::void_data
		   \exception EXCEPTION_SET::position_failure
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing subtractElement
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::subtractValue(type_array *&, asize_t &, const type_array &)
		   \brief Видаляє зазначений елемент з усіх позицій у масиві
		   \details На відміну від ALGOR::ArrayProcessing::subtractElement, що
		   видаляє лише один елемент у вказаній позиції, ця функція приймає не
		   позицію, а саме значення, що дозволяє його видалити з усіх позицій у
		   всьому масиві.
		   \param[in, out] Array Масив, у якому буде видалено всі елементи, що
		   відповідають заданому значенню
		   \param[in] array_size Розмір цього масиву
		   \param[in] value Значення, яке потрібно видалити з усього масиву
		   \since v0.1.0.0 commit 37cab7
		   \exception EXCEPTION_SET::void_data
		   \exception EXCEPTION_SET::value_failure
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing subtractValue
		 */

		/*!
		   \fn ALGOR::ArrayProcessing::copy(type_array *, const type_array *, const asize_t &, asize_t, asize_t)
		   \brief Копіює масив
		   \details Функція копіювання масиву. Але це не проста функція, а
		   багатофункціональна. Окрім того, що треба задати масив, з якого
		   копіюються данні, масив, до якого копіюються данні та обсяг данних,
		   які потрібно скопіювати, можна ще задати позиції у цих масивах, а
		   саме: з якої позиції почати копіювати данні та з якої позиції почати
		   записувати данні до масива. \n Для прикладу, Ви можете задати функції,
		   щоб вона скопіювала з 5 по 10 елемент зі старого масиву (усього п'ять
		   з п'ятої позиції) до нового масиву, при чому почати зберігатися
		   елементи повинні у новому масиві з п'ятої позиції (див. приклад).
		   \param[in, out] new_array Масив, у який копіюються дані
		   \param[in] old_array Масив, з якого потрібно скопіювати дані
		   \param[in] size_of_copied Параметр, який вказує, скільки елементів
		   потірбно скопіювати
		   \param[in] position_in_new_array Позиція, з якої починається запис в
		   масив, до якого копіюються дані
		   \param[in] position_in_old_array Позиція, з якої починається читання
		   у масиві, з якого копіюються дані
		   \since v0.0.0.3 commit 1a11a0
		   \warning До функції не передаються розміри масивів, через що функція не
		   може перевірити, чи задаєте ви їй правильні данні. Через це програміст
		   має бути дуже обережним з цією функцією
		   \test
		   \snippet Algor_ArrayProcessing.cpp processing copy
		 */

	/*!
	   \struct ALGOR::Array
	   \brief Структура, що імітує масив
	   \details Призначений для зберігання вказівника на динамічний масив та його
	   розмір
	   \tparam type_array Тип елементів, що зберігаються в масиві
	   \since v0.0.1.0 commit 979bf4
	   \warning Структуру можна створити будь-якого типу, але функції та класи
	   підтримують тільки 5 типів: \a byte8_t, \a ubit64_t, \a fbit64_t,
	   \a fbit128_t та \a asize_t. Тому будь-які інші типи можна використовувати
	   тільки тоді, коли дана структура не буде взаємоді'яти з функіоналом
	   бібліотеки, інакше ви зіштовхнетесь з помилкою <em>"undefined reference
	   to"</em>.
	   \test
	   \snippet Algor_core.cpp array struct
	 */

		/*!
		   \var ALGOR::Array::array
		   \brief Вказівник на масив
		   \since v0.0.1.0 commit 979bf4
		 */

		/*!
		   \var ALGOR::Array::array_size
		   \brief Розмір масиву
		   \since v0.0.1.0 commit 979bf4
		 */

	/*!
	   \fn ALGOR::create_struct(const asize_t &, bool)
	   \brief Створює структуру з покажчиком на масив
	   \details Зберігає розмір масиву, виділяє пам'ять під цей самий масив та повертає
	   вказівник на структуру масиву.
	   \tparam type_array Тип елементів, що будуть зберігатися у масиві
	   \param[in] SIZE Розмір створюваного масиву
	   \param[in] mem_allocation Логічний флаг, чи потрібно виділяти пам'ять під масив
	   \retval Array<type_array>* вказівник на створену структуру
	   \since v0.1.0.0 commit 85698d
	   \remark Якщо ви вже виділили пам'ять під масив, то структурі не потрібно повторно
	   виділяти пам'ять. Структура лише зберігає розмір масиву та сам вказівник на цей
	   масив. Тому у цьому випадку флагу \a mem_allocation потрібно передати \a false і
	   після цього зберегти вказівник на масив у структурі. У інших випадках флаг
	   \a mem_allocation краще не змінювати.
	   \test
	   \snippet Algor_core.cpp create_struct
	 */

	/*!
	   \fn ALGOR::generate_struct(Array<type_array> *&, const sbit64_t &, const sbit64_t &, const ubit64_t, const ubit32_t)
	   \brief Генерує випадкові значення у структурі масиву
	   \details Генерує у структурі масиву значення із заданого діапазону. Якщо
	   задати \a denominator, то можна отримати кратні, чи дрібні значення данних.
	   \tparam type_array Вказує якого типу будуть генеруватися числа у структурі
	   масиву
	   \param[in, out] Array Структура масиву, у якій потрібно згенерувати данні
	   \param[in] min_limit Мінімально можливе згенероване значення
	   \param[in] max_limit Максимально можливе згенероване значення
	   \param[in] seed Сі́м'я генератору
	   \param[in] denominator Дільник для генерації \a float данних
	   \since v0.1.3.0 commit ca0704
	   \note На випадок, якщо не працює ALGOR::getMemoryCell, можна власноруч
	   задати сі́м'я генерації.
	   \test
	   \snippet Algor_core.cpp generate_struct
	 */

	/*!
	   \fn ALGOR::remove_struct(Array<type_array> *&)
	   \brief remove_struct
	   \details Звільняє пам'ять від масиву, що зберігається у структурі й звільняє
	   з пам'яті саму структуру
	   \tparam type_array Тип елементів, що зберігаються у масиві
	   \param[in, out] Array Масив, який потрібно видалити
	   \result Вказівник на структуру після виклику цієї функції буде вказувати на
	   \a nullptr.
	   \since v0.0.0.1
	   \test
	   \snippet Algor_core.cpp remove_struct
	 */

	/*!
	   \class ALGOR::ArrayBase
	   \brief Базовий клас, від якого успадковуються інші класи, пов'язані з роботою
	   з масивами
	   \warning Об'єкт цього класу не можна створити!
	   \details Базовий клас, призаначений для використання класами-нащадками, що
	   використовуються при роботі з масивами. Цей клас містить готові конструктори та
	   готове поле для зберігання вказівника на структуру масиву. Використовується,
	   щоб не писати повторно у кожному класі одну й ту ж реалізацію конструкторів
	   та не прописувати заново поле вказівника. А отже буде менше коду.
	   \tparam type_array Тип елементів, що зберігаються у структурі об'єкту масиву
	   \since v0.1.0.0 commit 6efeb8
	   \paragraph Історія
	   На відміну від інших класів, у класу ALGOR::ArrayBase найрізноманітніша та
	   цікава історія. Його еволюція відбувалась 4 комміти поспіль і від першої
	   реалізації він ніс трохи інший сенс свого існування...\n
	   Більш детально читайте на сторінці \ref ArrayBaseHistory.md
	   \image html ArrayProcessingFamilyTree.png
	   \image latex ArrayProcessingFamilyTree.png "My application" width=10cm
	 */

		/*!
		   \fn ALGOR::ArrayBase::ArrayBase(Array<type_array> *&)
		   \brief Конструктор базового класу, що приймає СТРУКТУРУ та зберігає її
		   до поля
		   \details Конструктор, що приймає структуру для збереження вказівника на неї.
		   Спочатку конструктор перевіряє, чи не є масив пустим. Якщо масив
		   пустий - кидається виключення. Інакше - зберігається вказівник.
		   \warning При такому створенні об'єкта класу обидві сутності будуть
		   зберігати вказівники на одну й ту саму структуру, а тому зміна масиву
		   через одну із сутностей буде впливати на обидві сутності!!!
		   \param[in] Array Покажчик на структуру масиву
		   \since v0.1.0.0 commit 6efeb8
		   \exception EXCEPTION_SET::void_data
		 */

		/*!
		   \fn ALGOR::ArrayBase::ArrayBase(const asize_t &)
		   \brief Конструктор базового класу, що приймає РОЗМІР та виділяє пам'ять
		   \details Конструктор, що виділяє пам'ять під абсолютно новий чистий масив.
		   \warning Передача нульового розміру сприймається за збереження пустого
		   масиву, що заборонено правилами безпеки бібліотеки ALGOR:
		   > Об'єкти класів масивів не мають зберігати пусті масиви, щоб уникнути
		   > непередбачуваної поведінки та запобігти вилітам програм.
		   \param[in] SIZE Розмір створюваного масиву
		   \since v0.1.0.0 commit 1d50a2
		   \exception EXCEPTION_SET::void_data
		 */

		/*!
		   \fn ALGOR::ArrayBase::ArrayBase()
		   \brief Пустий конструктор
		   \details Просто пустий конструктор, який нічого не виконує.
		   \since v0.1.0.0 commit 48aa64, dd5d42+
		   \deprecated Раніше він використовувася у тих випадках, коли виділяти
		   пам'ять під структуру не потрібно (так як вказівнику не було присвоєно
		   nullptr і це робив даний конструктор), але з часом вказівнику було
		   присвоєно nullptr і надібність у цьому відпала... А цей метод залишено
		   на випадок, якщо колись з'явиться необхідність написати якусь
		   реалізацію у конструкторі базового класу.
		 */

		/*!
		   \fn ALGOR::ArrayBase::verification(Array<type_array> *)
		   \brief Метод перевірки масиву
		   \details Метод, що перевіряє масив на пустотність. Якщо розмір масиву
		   дорівнює нулю, можна вважати, що масив пустий, так як вказівник на сам
		   масив вказує на nullptr. Зазвичай метод використовується для перевірок
		   структур перед тим, як зберегти вказівник на структуру до об'єкту класа,
		   щоб до класу не міг потрапити пустий масив.
		   \param[in] Array Масив, що перевіряється
		   \since v0.1.1.0 commit 8bbf75
		   \exception EXCEPTION_SET::void_data
		   \paragraph Історія
		   Історія цього методу не така цікава, як у класа ArrayBase, але його життя
		   добре потріпало.\n
		   Спочатку це мала бути прихована функція, що видна лише усередині
		   бібліотеки. Для цього я всього лиш написав її у файлі реалізацій без її
		   оголошення у хідері. Такою вона залишалась довгий час... Але прийшов
		   час зайнятись безпекою бібліотеки перед релізом v1.0.0.0, так як з
		   останньої безпекозації (коли й було додано цю функцію) багато чого
		   змінилось. У релізі v0.1.3.0 проводилась реформа ARRAYDATA, коли тимчасово
		   став публічним ARRAYDATA::remove. Спочатку цю функцію було перейменовано, а
		   потім і взагалі тимчасово видалено. Чому тимчасово? Тому що коли я удруге
		   прийшов до концепції, що об'єкт класу масиву не має зберігати пустий
		   масив, я назад приховав ARRAYDATA::remove, довів рівень безпеки
		   до потрібного рівня і повернув цю функцію, як метод базового класу, який
		   можуть використовувати успадковані класи при збережені до себе масивів.\n
		   Короче, судьби ArrayBase та verification перетнулися. Дивлячись на
		   історію ArrayBase, розумієш, що це вийшло не випадково...
		   \note Можливо у майбутньому буде проводитись більше перевірок, якщо
		   кількість характеристик зросте.
		 */

		/*!
		   \var ALGOR::ArrayBase::ARRAY
		   \brief Вказівник на структуру, що зберігає масив
		   \since v0.1.0.0 commit 6efeb8
		 */

	/*!
	   \class ALGOR::ARRAYDATA
	   \brief Клас з потужним функціоналом обробки масивів
	   \details Це головний клас для роботи з масивами, завданнями якого є зберігання
	   вказівника на структуру масиву та його обробка. Клас має потужний функціонал:
	   клонування, пошук, перевизначення, характеризація тощо. А достатня кількість
	   перевантажених операторів багатократно полегшує роботу з даними.
	   \tparam type_array Тип елементів, що зберігаються у структурі об'єкту масиву
	   \since v0.0.0.1
	   \remark У вас можуть виникнути питання щодо версіонування. Тема роз'яснена
	   на наступній сторінці \ref ArrayBaseHistory.md
	   \image html ArrayProcessingFamilyTree.png
	   \image latex ArrayProcessingFamilyTree.png "My application" width=10cm
	 */

		/*!
		   \fn ALGOR::ARRAYDATA::ARRAYDATA(Array<type_array> *&)
		   \brief Конструктор, що приймає СТРУКТУРУ та зберігає її до поля
		   \details Читай детальніше ALGOR::ArrayBase::ArrayBase(Array<type_array> *&)
		   \param[in] Array Покажчик на структуру масиву
		   \since v0.1.0.0 commit 48aa64
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA constructor struct
		   \sa ALGOR::ArrayBase::ArrayBase(Array<type_array> *&)
		 */

		/*!
		   \fn ALGOR::ARRAYDATA::ARRAYDATA(const asize_t &)
		   \brief Конструктор, що приймає РОЗМІР та виділяє пам'ять
		   \details Читай детальніше ALGOR::ArrayBase::ArrayBase(const asize_t &)
		   \param[in] SIZE Розмір створюваного масиву
		   \since v0.1.0.0 commit 1d50a2
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA constructor size
		   \sa ALGOR::ArrayBase::ArrayBase(const asize_t &)
		 */

		/*!
		   \enum ALGOR::ARRAYDATA::ArrayType
		   \brief Набір типів масиву
		   \details Перелік типів масиву. Використовується тільки методом
		   ALGOR::ARRAYDATA::searcherOccurrencesOfSubstring для правильного
		   виконання алгоритму.
		   \since v0.1.0.0 commit 85698d
		 */

			/*!
			   \var ALGOR::ARRAYDATA::ArrayType::NUMBER
			   \brief Вказує, що масив зберігає числа
			   \details Грубо кажучи, значення вказує алгоритму, що він працює з
			   масивом чисел. Насправді алгоритм використовує значення типу
			   масиву з переліку у своїх перевірках. Це потрібно для правильної
			   роботи алгоритму, оскільки з числовими та строковими данними він
			   працює по різному.
			   \since v0.1.0.0 commit 85698d
			 */

			/*!
			   \var ALGOR::ARRAYDATA::ArrayType::STRING
			   \brief Вказує, що масив зберігає строки
			   \details Грубо кажучи, значення вказує алгоритму, що він працює з
			   масивом-строкою. Насправді алгоритм використовує значення типу
			   масиву з переліку у своїх перевірках. Це потрібно для правильної
			   роботи алгоритму, оскільки зі строковими та числовими данними він
			   працює по різному.
			   \since v0.1.0.0 commit 85698d
			 */

		/*!
		   \struct ALGOR::ARRAYDATA::mode
		   \brief Структура моди масиву
		   \details Розширена структура масиву. По суті це теж є масив. Масив
		   чисел, що зберігає всі числа, що найчастіше зустрічаються у
		   головному масиві. Але як дізнатись, з якою саме частотою? Для цього
		   і було розширено стандартну структуру ALGOR::Array полем для
		   зберігання цієї частоти. З цієї структури можна дізнатись, які
		   числа можна найчастіше зустріти (ALGOR::ARRAYDATA::mode::array),
		   скільки їх (ALGOR::ARRAYDATA::mode::array_size) та з якою частотою
		   вони зустрічаються (ALGOR::ARRAYDATA::mode::highest_frequency).
		   \warning На відміну від структури ALGOR::Array, для структури
		   ALGOR::ARRAYDATA::mode не реалізовано функціонал для звільнення
		   пам'яті після використання данних, тому програмісту самому потрібно
		   звільняти пам'ять.
		   \since v0.1.3.0 commit 391fff
		   \note Приклад використовується такий самий, як і для
		   ALGOR::ARRAYDATA::moda.
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA moda
		 */

			/*!
			   \var ALGOR::ARRAYDATA::mode::highest_frequency
			   \brief Частота моди
			   \since v0.1.3.0 commit 391fff
			 */

		/*!
		   \fn ALGOR::ARRAYDATA::generatedData(const sbit64_t &, const sbit64_t &, const ubit64_t, const ubit32_t)
		   \brief Метод, який заповнює весь масив випадковими значеннями
		   \details
		   \param[in] min_limit Мінімальне значення, яке можна згенерувати
		   \param[in] max_limit Максимальне значення, яке можна згенерувати
		   \param[in] seed Сі́м'я генератору
		   \param[in] denominator Дільник для генерації \a float данних
		   \since v0.0.0.1
		   \remark У вас можуть виникнути питання щодо версіонування. Цей метод був
		   присутній з самого початку, але у версії v0.1.3.0 commit ca0704 я
		   вирішив виокремити алгоритм генерації чисел (точніше сказати, алгоритм
		   обробки згенерованих чисел) до функції ALGOR::generate_struct. Тоді
		   реалізація була перенесена з цього методу, а тут залишився лише
		   виклик нової функції. І якщо не дивитись на реалізації, то, по суті,
		   це і є перший метод.
		   \note На випадок, якщо не працює ALGOR::getMemoryCell, можна власноруч
		   задати сі́м'я генерації.
		   \test
		   \snippet Algor_ArrayData.cpp ARRAYDATA generatedData
		 */


























/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                ALGOR_SORTING                                *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

/*!
Sorting
*/

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                 ALGOR_MATRIX                                *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

/*!
Matrix
*/

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                  ALGOR_HEAP                                 *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

/*!
Heap
*/

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                  ALGOR_LIST                                 *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

/*!
List
*/