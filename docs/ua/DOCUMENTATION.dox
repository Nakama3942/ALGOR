/* **************************   DOCUMENTATION.dox   ************************** *
 * --------------------------------------------------------------------------- *
 *                                                                             *
 * Copyright © 2022 Kalynovsky Valentin. All rights reserved.                  *
 *                                                                             *
 * Licensed under the Apache License, Version 2.0 (the "License");             *
 * you may not use this file except in compliance with the License.            *
 * You may obtain a copy of the License at                                     *
 *                                                                             *
 *     http://www.apache.org/licenses/LICENSE-2.0                              *
 *                                                                             *
 * Unless required by applicable law or agreed to in writing, software         *
 * distributed under the License is distributed on an "AS IS" BASIS,           *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    *
 * See the License for the specific language governing permissions and         *
 * limitations under the License.                                              *
 *                                                                             *
 * --------------------------------------------------------------------------- *
 * *************************************************************************** *
 */

/*!
  \namespace ALGOR
  \brief Глобальний простір імен усього проекту
  \details Призначений для зберігання усього реалізованого функціоналу проекту.
  Краще не використовувати разом з std, інакше можуть виникнути конфлікти.
  \since v0.1.2.0 commit 2fa93b
 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                  ALGOR_CORE                                 *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

	/*!
	   \typedef ALGOR::byte1_t
	   \brief Аліас для char <em>(1 байт)</em>.
	   \details Зазвичай використовується для задання типу строк. Може зберігати
	   число від <b>0</b> до <b>255</b>, або від <b>-128</b> до <b>+127</b>.
	   \since v0.1.3.0 commit b50b4a
	   \note Якщо цей тип дійсно використовується для строк, то не забувайте
	   вказувати "*" (вказівник) перед назвою імені строки, так як цей тип
	   не замінює повністю char на string. Це лише звичайний аліас.
	 */
	 
	/*!
	   \typedef ALGOR::byte2_t
	   \brief Аліас для short <em>(2 байти)</em>.
	   \details Зазвичай використовується при зберіганні коротких чисел
	   від <b>0</b> до <b>65'535</b>, або від <b>-32'768</b> до <b>+32'767</b>.
	   \since v0.1.3.0 commit b50b4a
	 */

	/*!
	   \typedef ALGOR::byte4_t
	   \brief Аліас для long <em>(4 байти)</em>.
	   \details Зазвичай використовується при зберіганні чисел. Може
	   зберігати від <b>0</b> до <b>4'294'967'295</b>, або від <b>-2'147'483'648</b>
	   до <b>+2'147'483'647</b>.
	   \since v0.1.3.0 commit b50b4a
	   \note Також ним можна повноцінно замінити тип int, так як він теж
	   розрахований на 4 байти. Але якщо програму запустити на комп'ютері
	   з процесором intel i386 чи більш ранішим, то під int буде виділятися усього
	   2 байти і на тих процесорах int є аліасом для short. Через таке розпливчате
	   поняття типу int він ніде у бібліотеці не використовується, а використовуються
	   чіткі типи типу short чи long.
	 */

	/*!
	   \typedef ALGOR::byte8_t
	   \brief Аліас для long long <em>(8 байтів)</em>.
	   \details Є розширенням типу long у два рази і розрахований під числа від <b>0</b>
	   до <b>18'446'744'073'709'551'615</b>, або від <b>-9'223'372'036'854'775'808</b>
	   до <b>+9'223'372'036'854'775'807</b>.
	   \since v0.1.3.0 commit b50b4a
	 */

	/*!
	   \typedef ALGOR::sbit8_t
	   \brief Аліас для signed char <em>(1 байт)</em>.
	   \details Аналогічно звичайному char, але може приймати значення тільки
	   від <b>-128</b> до <b>+127</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::sbit16_t
	   \brief Аліас для signed short <em>(2 байти)</em>.
	   \details Аналогічно звичайному short, але може приймати значення тільки
	   від <b>-32'768</b> до <b>+32'767</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::sbit32_t
	   \brief Аліас для signed long <em>(4 байти)</em>.
	   \details Аналогічно звичайному long, але може приймати значення тільки
	   від <b>-2'147'483'648</b> до <b>+2'147'483'647</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::sbit64_t
	   \brief Аліас для signed long long <em>(8 байтів)</em>.
	   \details Аналогічно звичайному long long, але може приймати значення тільки
	   від <b>-9'223'372'036'854'775'808</b> до <b>+9'223'372'036'854'775'807</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::ubit8_t
	   \brief Аліас для unsigned char <em>(1 байт)</em>.
	   \details Аналогічно звичайному char і на відміну від signed char може
	   приймати значення тільки від <b>0</b> до <b>255</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::ubit16_t
	   \brief Аліас для unsigned short <em>(2 байти)</em>.
	   \details Аналогічно звичайному short і на відміну від signed short може
	   приймати значення тільки від <b>0</b> до <b>65'535</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::ubit32_t
	   \brief Аліас для unsigned long <em>(4 байти)</em>.
	   \details Аналогічно звичайному long і на відміну від signed long може
	   приймати значення тільки від <b>0</b> до <b>4'294'967'295</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::ubit64_t
	   \brief Аліас для unsigned long long <em>(8 байтів)</em>.
	   \details Аналогічно звичайному long long і на відміну від signed long long
	   може приймати значення тільки від <b>0</b> до <b>18'446'744'073'709'551'615</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::fbit32_t
	   \brief Аліас для float <em>(4 байти)</em>.
	   \details На відміну від всіх попередніх типів, що можуть зберігати тільки
	   цілі числа, тип \a float може зберігати числа з плаваючою комою. У
	   комірку можна записати як додатні, так і від'ємні числа. Можливий діапазон
	   зберігаємих чисел від <b>+/-3.4E-38</b> до <b>3.4E+38</b>.
	   \since v0.1.2.0 commit 1981d6
	 */

	/*!
	   \typedef ALGOR::fbit64_t
	   \brief Аліас для double <em>(8 байтів)</em>.
	   \details Розширює тип \a float, збільшуючи точність та розмір у два рази.
	   Можливий діапазон зберігаємих чисел від <b>+/-1.7E-308</b> до <b>1.7E+308</b>.
	   \since v0.1.2.0 commit 1981d6
	 */

	/*!
	   \typedef ALGOR::fbit128_t
	   \brief Аліас для long double <em>(16 байт)</em>.
	   \details Розширює тип \a double, збільшуючи точність та розмір іще у два
	   рази.
	   \since v0.1.3.0 commit b6349a
	 */

	/*!
	   \typedef ALGOR::asize_t
	   \brief Псевдонім для визначення типу <em>"розмір массиву"</em>.
	   \details Зазвичай цей тип використовується, коли треба вказати розмір масиву
	   чи позицію у масиві. Так як нумерація починається з 0 і не існує від'ємних
	   розмірів масивів чи номерів позицій, можна поточнити тип з <a>int</a> до
	   <a>unsigned int</a>. До того ж не завжди вистачає <b>65'535</b> комірок масиву.
	   Іноді потрібно більше, наприклад, мільйон чи мільярд. Більше мільярда нема
	   сенсу створювати структури даних тому ідеальним вибором серед <a>short</a>,
	   <a>long</a> та <a>long long</a> є <a>long</a>. Саме тому <a>asize_t</a> є
	   аліасом до <a>ubit32_t</a>.
	   \since v0.1.0.0 commit 89658e
	 */

	/*!
	   \typedef ALGOR::memcell_t
	   \brief Псевдонім для обчислюваної <em>комірки пам'яті</em>.
	   \details використовується тільки у функції \a getMemoryCell(). Є службовим типом
	   і замість нього краще використовувати \a ubit64_t.
	   \since v0.1.1.3 commit b4cdc9
	 */

	/*!
	   \fn ALGOR::swap(type_value &, type_value &)
	   \brief Міняє місцями два елементи
	   \details Функція приймає два значення, які треба замінити місцями. Після
	   виконання функції перша комірка пам'яті буде зберігати друге значення, а
	   друга - перше. Для виконання алгоритму використовується додаткова
	   комірка пам'яті.
	   \tparam type_value Тип елементів, що міняються місцями
	   \param[in, out] firstNumber Перший елемент для заміни
	   \param[in, out] secondNumber Другий елемент для заміни
	   \since v0.0.0.1
	   \paragraph Приклад
	   \code{.cpp}
	   int value1 = 5, value2 = 10;
	   CORE::swap(value1, value2);
	   cout << value2 << "\n"; //print 5
	   \endcode
	   \paragraph Реалізація
	 */

	/*!
	   \fn ALGOR::minimum(type_value, type_value)
	   \brief Повертає найменше значення з двух наданих
	   \details Функція приймає два значення і порівнює їх. Якщо перше
	   число виявится меншим за друге - функція повертає перше число, інакше -
	   друге.
	   \tparam type_value Тип елементів, з яких вибирається найменше значення
	   \param[in] firstNumber Перше значення на вибірку
	   \param[in] secondNumber Друге значення на вибірку
	   \since v0.1.1.4 commit 090b06
	   \return найменше значення з двух наданих
	   \paragraph Приклад
	   \code{.cpp}
	   int value1 = 5, value2 = 10;
	   cout << CORE::minimum(value1, value2) << "\n"; //print 5
	   \endcode
	   \paragraph Реалізація
	 */

	/*!
	   \fn ALGOR::maximum(type_value, type_value)
	   \brief Повертає найбільше значення з двух наданих
	   \details Функція приймає два значення і порівнює їх. Якщо перше
	   число виявится більшим за друге - функція повертає перше число, інакше -
	   друге.
	   \tparam type_value Тип елементів, з яких вибирається найбільше значення
	   \param[in] firstNumber Перше значення на вибірку
	   \param[in] secondNumber Друге значення на вибірку
	   \since v0.1.1.4 commit 090b06
	   \return найбільше значення з двух наданих
	   \paragraph Приклад
	   \code{.cpp}
	   int value1 = 5, value2 = 10;
	   cout << CORE::maximum(value1, value2) << "\n"; //print 10
	   \endcode
	   \paragraph Реалізація
	 */

	/*!
	   \fn ALGOR::getMemoryCell(memcell_t, memcell_t)
	   \brief Повертає випадкове число; аналог time(NULL)
	   \details Цей метод виділяє пам'ять під 10 комірок пам'яті. Куди саме система
	   виділить пам'ять передгадати неможливо, а також неможливо передгадати, яка
	   програма і які данні раніше сюди записувала, тому це самий реальний генератор
	   випадкович чисел. Поки генерація масивів не була доведена до ідеалу, але як
	   генераточ великого числа замість time(NULL) цілком реально використати. Із
	   десяти випадкових чисел функція розраховує число, яке треба повернути.
	   \param[in] right_adjust Правий здвиг
	   \param[in] left_adjust Лівий здвиг
	   \since v0.1.1.3 commit b4cdc9
	   \remark Функції можна задати бітовий здвиг. Якщо функція використовується
	   замість time(NULL), а результат передається у іншу функцію, що приймає тільки
	   чотири-байтове значення, можна задати правий здвиг на 32 біти (4 байти) і
	   тоді функція поверне 4 старших байти.
	   \retval cell - розраховане випадкове число
	   \paragraph Приклад
	   \code{.cpp}
	   cout << CORE::getMemoryCell() << "\n"; //print 185214324139604
	   \endcode
	   \paragraph Реалізація
	 */

	/*!
	   \interface ALGOR::Printer
	   \brief Printer-інтерфейс, призначений для реалізації функціоналу виводу
	   інформації
	   \details Це є інтерфейс, що складається лише з одного віртуального методу, який
	   призначений для виводу інформації. Так як цей проект є унікальним у тому сенсі,
	   що не використовується жодна інша бібліотека (навіть стандартна) і автор
	   власноруч пише власну реалізацію алгоритмів - тому неможливо використати
	   клас iostream, через що неможлива реалізація принтеру. Автору потрібно буде з
	   початку написати власний клас вводу-виводу, а в умовах популярності графічних
	   інтерфейсів це не є оптимальним та актуальним. Краще програмісту самому дати
	   реалізувавти ввод-вивід. До того ж такий метод є універсальним: його можна
	   використовувати й у консольних програмах, й у графічних. Якби я намагався
	   власноруч написати реалізацію, вона була б спеціалізованою чи під консоль, чи
	   під графіку. Саме це мене підштовхнуло написати саме інтрерфейс, а не клас.
	   \since v0.1.2.0 commit 2fa93b
	   \remark
	   Раджу використовувати наступну реалізацію для консольної програми:
	   \code{.cpp}
	   template <typename type_array>
	   class printer : public CORE::Printer
	   {
	   public:
		   void setData(Array<type_array> **ARRAY)
		   {
			   Array = ARRAY;
		   }
		   void print() override
		   {
			   for (asize_t i = 0; i < (*Array)->array_size; i++)
			   {
				   cout << " " << (*Array)->array[i];
			   }
			   cout << "\n";
		   }
	   private:
		   Array<type_array> **Array;
	   };
	   \endcode
	   Цей клас зберігає не матрицю, а вказівник на вказівник на структуру масиву.
	   Тому достатньо один раз передати у клас вказівник на структуру і все. Далі
	   можна просто міняти вказівники на інші структури з іншими масивами і не
	   треба їх заново передавати у цей клас. Він сам буде відстежувати, який
	   вказівник зберігається у вказівнику на структуру.
	 */

		/*!
		   \fn ALGOR::Printer::print()
		   \brief Метод для виводу інформації
		   \since v0.1.2.0 commit 2fa93b
		   \paragraph Приклад
		   \code{.cpp}
		   //Створюю вказівник на структуру
		   Array<byte8_t> *D;

		   //Створюю об'єкт принтера і передаю йому посилання на структуру
		   printer<byte8_t> *pr = new printer<byte8_t>;
		   pr->setData(&D);

		   //Створюю об'єкт класу масиву та генерую данні
		   ARRAYDATA<byte8_t> *A = new ARRAYDATA<byte8_t>(35);
		   A->generatedData(10, 1000);

		   //Зберігаю у структурі вказівник на масив
		   D = A->getData();

		   //Виводжу данні
		   pr->print();
		   \endcode
		 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                               ALGOR_EXCEPTION                               *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

	/*!
	  \namespace ALGOR::EXCEPTION_SET
	  \brief Простір імен, що реалізовує виключення
	  \details Простір імен являє собою набір класів, які використовуються при киданні
	  виключень, так як зберігають необхідну інформацію про випадок, що стався. Головний
	  клас \a Exception являє собою каркас винятка, який можна успадкувати для
	  полегшення роботи з винятками. Можна дати додаткову інформацію до вже реалізованих
	  класів-нащадків, а можна створити власні класи-нащадки.
	  \since v0.1.3.0 commit 2cdff0
	 */

		/*!
		   \class ALGOR::EXCEPTION_SET::Exception
		   \brief Клас-каркас для роботи з винятками
		   \details Клас, що зберігає данні про виняток (номер винятка, деталі та
		   пояснення). Щоб створити об'єкт винятку достатньо переадти необхідні данні
		   конструктору, а для отримання інформації про виняток треба його перехопити
		   і використати метод, що повертає необхідні данні.
		   \since v0.1.1.0 commit c62e85
		   \paragraph Приклад
		   \code{.cpp}
		   try
		   {
			   throw EXCEPTION_SET::Exception(55, "details", "explanation");
		   }
		   catch (EXCEPTION_SET::Exception ex)
		   {
			   cout << "Code: " << ex.code() << ";\n" << ex.what() << "\n-> " << ex.why() << "\n";
		   }
		   //print:
		   //  Code: 55;
		   //  details
		   //  -> explanation
		   \endcode
		   \paragraph Реалізація
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::Exception(ubit16_t, const byte1_t *, const byte1_t *)
			   \brief Розширений конструктор класу винятків
			   \details Конструктор, що приймає розширену кількість данних, а саме код
			   винятку, деталі винятку, та пояснення до деталей, що не завжди буває
			   необхідним.
			   \param[in] CODE Код Exception
			   \param[in] DETAILS Деталі Exception
			   \param[in] EXPLANATION Пояснення Exception
			   \since v0.1.3.0 commit 2c6408
			   \remark Цей конструктор є розширеним так як дозволяє успадкованим класам
			   надати пояснення до винятку, коли це необхідно, що робить цей клас
			   більш універсальним.
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::Exception(100, "details", "explanation");
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::Exception(ubit16_t, const byte1_t *)
			   \brief Стандартний конструктор класу винятків
			   \details Конструктор, що приймає базову кількість данних про виняток.
			   Зазвичай номеру та деталей помилки буває достатньо.
			   \param[in] CODE Код Exception
			   \param[in] DETAILS Деталі Exception
			   \since v0.1.1.0 commit c62e85
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::Exception(100, "details");
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::Exception(ubit16_t)
			   \brief Скорочений кодовий конструктор класу винятків
			   \details Конструктор, що приймає скорочену кількість данних про
			   виняток. Єдині данні, що зберігаються у об'єкті винятку, це номер
			   винятку.
			   \param[in] CODE Код Exception
			   \since v0.1.1.0 commit c62e85
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::Exception(100);
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::Exception(const byte1_t *)
			   \brief Скорочений детальний конструктор класу винятків
			   \details Конструктор, що приймає скорочену кількість данних про
			   виняток. Єдині данні, що зберігаються у об'єкті винятку, це деталі
			   винятку.
			   \param[in] DETAILS Деталі Exception
			   \since v0.1.1.0 commit c62e85
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::Exception("details");
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::code()
			   \brief Метод, що повідомляє номер винятку
			   \details Повертає номер винятку, що зберігається в об'єкті.
			   \since v0.1.1.0 commit c62e85
			   \retval CODE - номер винятку
			   \paragraph Приклад
			   \code{.cpp}
			   catch (EXCEPTION_SET::Exception ex)
			   {
				   cout << ex.code() << "\n"; //print 100
			   }
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::what()
			   \brief Метод, що повідомляє деталі винятку
			   \details Повертає деталі винятку, що зберігаються в об'єкті.
			   \since v0.1.1.0 commit c62e85
			   \retval DETAILS - деталі винятку
			   \paragraph Приклад
			   \code{.cpp}
			   catch (EXCEPTION_SET::Exception ex)
			   {
				   cout << ex.what() << "\n"; //print "details"
			   }
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::Exception::why()
			   \brief Метод, що дає пояснення винятку
			   \details Повертає пояснення винятку, що зберігається в об'єкті.
			   \since v0.1.3.0 commit 2c6408
			   \retval EXPLANATION - пояснення винятку
			   \paragraph Приклад
			   \code{.cpp}
			   catch (EXCEPTION_SET::Exception ex)
			   {
				   cout << ex.why() << "\n"; //print "explanation"
			   }
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \var ALGOR::EXCEPTION_SET::Exception::CODE
			   \brief Номер винятку
			   \since v0.1.1.0 commit c62e85
			 */

			/*!
			   \var ALGOR::EXCEPTION_SET::Exception::DETAILS
			   \brief Деталі винятку
			   \since v0.1.1.0 commit c62e85
			 */

			/*!
			   \var ALGOR::EXCEPTION_SET::Exception::EXPLANATION
			   \brief Пояснення винятку
			   \since v0.1.3.0 commit 2c6408
			 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep55
		   \brief Повідомлення для memory_overflow
		   \since v0.1.3.0 commit d66e53
		   \paragraph Текст повідомлення
		   <em>"Комірка пам'яті, в якій зберігається розмір обсягу даних, більше
		   не може зберігати більше. Ця помилка може виникнути у випадках, коли
		   в комірку, яка може зберігати змінну 0xffffffff, потрібно записати
		   більше значення, тобто більше 4 байт, оскільки клітинка зберігання
		   даних займає 4 байти"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep101
		   \brief Повідомлення для division_by_zero
		   \since v0.1.3.0 commit d66e53
		   \paragraph Текст повідомлення
		   <em>"Відбулося ділення на нуль - невизначений результат виконання
		   програми"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep254
		   \brief Повідомлення для position_failure
		   \since v0.1.3.0 commit d66e53
		   \paragraph Текст повідомлення
		   <em>"Помилка позиції - позиція відсутня в масиві"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep255
		   \brief Повідомлення для value_failure
		   \since v0.1.3.0 commit d66e53
		   \paragraph Текст повідомлення
		   <em>"Помилка значення - значення відсутнє в масиві"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep256
		   \brief Повідомлення для size_failure
		   \since v0.1.3.0 commit d66e53
		   \paragraph Текст повідомлення
		   <em>"Помилка розміру - помилка зміни розміру; наприклад, це може
		   статися, коли розміри збігаються, коли розмір масиву змінюється, або
		   новий розмір більше/менше за межі розмірів"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep400
		   \brief Повідомлення для void_data
		   \since v0.1.3.0 commit d66e53
		   \paragraph Текст повідомлення
		   <em>"Отримано порожню структуру даних"</em>
		 */

		/*!
		   \var ALGOR::EXCEPTION_SET::excep404
		   \brief Повідомлення для not_found
		   \since v0.1.3.0 commit d66e53
		   \paragraph Текст повідомлення
		   <em>"Помилка пошуку - елемент не знайдено"</em>
		 */

		/*!
		   \class ALGOR::EXCEPTION_SET::memory_overflow
		   \brief Клас-виняток \a "memory_overflow"
		   \details Базовий виняток \a memory_overflow (переповнення пам'яті).
		   Використовує повідомлення EXCEPTION_SET::excep55 та має номер \a 55.
		   \since v0.1.1.0 commit bce6b6
		   \remark Де-які методи при киданні винятку \a 55 можуть давати пояснення.
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::memory_overflow::memory_overflow()
			   \brief Виняток memory_overflow
			   \details Конструктор об'єкту, що використовується, як виняток
			   memory_overflow. До каркасу передаються код виключення та деталі.
			   \since v0.1.1.0 commit bce6b6
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::memory_overflow();
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::memory_overflow::memory_overflow(const byte1_t *)
			   \brief Виняток memory_overflow з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   memory_overflow. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::memory_overflow("explanation");
			   \endcode
			   \paragraph Реалізація
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::division_by_zero
		   \brief Клас-виняток \a "division_by_zero"
		   \details Базовий виняток \a division_by_zero (ділення на нуль).
		   Використовує повідомлення EXCEPTION_SET::excep101 та має номер \a 101.
		   \since v0.1.2.0 commit d74cc1
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::division_by_zero::division_by_zero()
			   \brief Виняток division_by_zero
			   \details Конструктор об'єкту, що використовується, як виняток
			   division_by_zero. До каркасу передаються код виключення та деталі.
			   \since v0.1.2.0 commit d74cc1
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::division_by_zero();
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::division_by_zero::division_by_zero(const byte1_t *)
			   \brief Виняток division_by_zero з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   division_by_zero. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::division_by_zero("explanation");
			   \endcode
			   \paragraph Реалізація
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::position_failure
		   \brief Клас-виняток \a "position_failure"
		   \details Базовий виняток \a position_failure (збій положення).
		   Використовує повідомлення EXCEPTION_SET::excep254 та має номер \a 254.
		   \since v0.1.1.0 commit 8bbf75
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::position_failure::position_failure()
			   \brief Виняток position_failure
			   \details Конструктор об'єкту, що використовується, як виняток
			   position_failure. До каркасу передаються код виключення та деталі.
			   \since v0.1.1.0 commit 8bbf75
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::position_failure();
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::position_failure::position_failure(const byte1_t *)
			   \brief Виняток position_failure з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   position_failure. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::position_failure("explanation");
			   \endcode
			   \paragraph Реалізація
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::value_failure
		   \brief Клас-виняток \a "value_failure"
		   \details Базовий виняток \a value_failure (збій значення).
		   Використовує повідомлення EXCEPTION_SET::excep255 та має номер \a 255.
		   \since v0.1.1.0 commit 8bbf75
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::value_failure::value_failure()
			   \brief Виняток value_failure
			   \details Конструктор об'єкту, що використовується, як виняток
			   value_failure. До каркасу передаються код виключення та деталі.
			   \since v0.1.1.0 commit 8bbf75
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::value_failure();
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::value_failure::value_failure(const byte1_t *)
			   \brief Виняток value_failure з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   value_failure. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::value_failure("explanation");
			   \endcode
			   \paragraph Реалізація
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::size_failure
		   \brief Клас-виняток \a "size_failure"
		   \details Базовий виняток \a size_failure (збій розміру).
		   Використовує повідомлення EXCEPTION_SET::excep256 та має номер \a 256.
		   \since v0.1.3.0 commit 2c6408
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::size_failure::size_failure()
			   \brief Виняток size_failure
			   \details Конструктор об'єкту, що використовується, як виняток
			   size_failure. До каркасу передаються код виключення та деталі.
			   \since v0.1.3.0 commit 2c6408
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::size_failure();
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::size_failure::size_failure(const byte1_t *)
			   \brief Виняток size_failure з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   size_failure. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::size_failure("explanation");
			   \endcode
			   \paragraph Реалізація
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::void_data
		   \brief Клас-виняток \a "void_data"
		   \details Базовий виняток \a void_data (недійсні дані).
		   Використовує повідомлення EXCEPTION_SET::excep400 та має номер \a 400.
		   \since v0.1.1.0 commit c62e85
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::void_data::void_data()
			   \brief Виняток void_data
			   \details Конструктор об'єкту, що використовується, як виняток
			   void_data. До каркасу передаються код виключення та деталі.
			   \since v0.1.1.0 commit c62e85
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::void_data();
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::void_data::void_data(const byte1_t *)
			   \brief Виняток void_data з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   void_data. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::void_data("explanation");
			   \endcode
			   \paragraph Реалізація
			 */

		/*!
		   \class ALGOR::EXCEPTION_SET::not_found
		   \brief Клас-виняток \a "not_found"
		   \details Базовий виняток \a not_found (не знайдено).
		   Використовує повідомлення EXCEPTION_SET::excep404 та має номер \a 404.
		   \since v0.1.1.0 commit c62e85
		 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::not_found::not_found()
			   \brief Виняток not_found
			   \details Конструктор об'єкту, що використовується, як виняток
			   not_found. До каркасу передаються код виключення та деталі.
			   \since v0.1.1.0 commit c62e85
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::not_found();
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::EXCEPTION_SET::not_found::not_found(const byte1_t *)
			   \brief Виняток not_found з поясненням
			   \details Конструктор об'єкту, що використовується, як виняток
			   not_found. До каркасу передаються код виключення, деталі
			   та пояснення.
			   \param[in] explanation Пояснення до деталей винятку
			   \since v0.1.3.0 commit 2с6408
			   \paragraph Приклад
			   \code{.cpp}
			   throw EXCEPTION_SET::not_found("explanation");
			   \endcode
			   \paragraph Реалізація
			 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                 ALGOR_RANDOM                                *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

	/*!
	  \namespace ALGOR::RANDOM
	  \brief Простір імен, що реалізовує ГПВЧ
	  \details Простір імен являє собою набір класів, які використовуються при
	  Генерації ПсевдоВипадкових Чисел (ГПВЧ). Класи є реалізаціями математичних
	  моделей. Зазвичай використовуються при генерації структур даних, таких як
	  масиви тощо.
	  \since v0.1.3.0 commit d66e53
	 */

		/*!
		   \class ALGOR::RANDOM::LCM
		   \brief ГПВЧ Лінійний Конґруентний Метод
		   \details Один з найпростіших ГПВЧ. Працює за принципом розрахунку
		   наступного числа. Представляється формулою
		   \f[x_n = (a * x_{n-1} + c)mod(m)\f], де \f$a, c, m\f$ - константні
		   коефіціенти.
		   \since v0.1.3.0 commit ca0704
		   \remark LCM = LinearCongruentMethod
		   \paragraph Ресурси
		   Source: https://en.wikipedia.org/wiki/Linear_congruential_generator\n
		   Paragraph: Parameters in common use\n
		   Table row: MMIX by Donald Knuth\n
		   \paragraph Приклад
		   \code{.cpp}
		   RANDOM::LCM r(getMemoryCell());
		   cout << r.rand() << "\n"; //print 510610997
		   \endcode
		 */

			/*!
			   \fn ALGOR::RANDOM::LCM::LCM(memcell_t)
			   \brief Конструктор класу, що приймає сі́м'я
			   \details Конструктор, що приймає сі́м'я ГПВЧ, що є першим числом
			   послідовності, що генерується (\f$x_0\f$). Являє собою аналог
			   стандартної функції \a srand().
			   \param[in] seed
			   \since v0.1.3.0 commit ca0704
			   \paragraph Приклад
			   \code{.cpp}
			   RANDOM::LCM r(getMemoryCell());
			   \endcode
			   або \n
			   \code{.cpp}
			   RANDOM::LCM r(time(NULL));
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::RANDOM::LCM::rand()
			   \brief Метод генерації псевдовипадкового числа
			   \details Алгоритм, що генерує (\a розраховує) наступне число
			   послідовності.
			   \since v0.1.3.0 commit ca0704
			   \retval seed - наступне число послідновності \f$x_n\f$
			   \paragraph Приклад
			   \code{.cpp}
			   cout << r.rand() << "\n"; //print 510610997
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \var ALGOR::RANDOM::LCM::a
			   \brief Перше константне число \f$a\f$
			   \details Константа \f$a\f$ = 6'364'136'223'846'793'005.
			   \since v0.1.3.0 commit ca0704
			 */

			/*!
			   \var ALGOR::RANDOM::LCM::c
			   \brief Перше константне число \f$c\f$
			   \details Константа \f$c\f$ = 1'442'695'040'888'963'407.
			   \since v0.1.3.0 commit ca0704
			 */

			/*!
			   \var ALGOR::RANDOM::LCM::m
			   \brief Перше константне число \f$m\f$
			   \details Константа \f$m\f$ = 18'446'744'073'709'551'615.
			   \since v0.1.3.0 commit ca0704
			 */

			/*!
			   \var ALGOR::RANDOM::LCM::seed
			   \brief Сі́м'я послідовності \f$x_0\f$
			   \details Число, що задає початок послідовності, що генерується.
			   \since v0.1.3.0 commit ca0704
			 */

		/*!
		   \class ALGOR::RANDOM::RC4
		   \brief Простий криптостійкий генератор
		   \details RC4 — потоковий шифр, розроблений Роном Рівестом
		   (анг. Ron Rivest) у 1987 році.
		   \since v0.1.0.0 commit 88415c
		   \note Може генерувати значення лише у діапазоні 0-255 (1 байт).
		   \deprecated На даному етапі розробка даного ГВЧ заморожена. Алгоритм
		   застарів. З часом можливе його повне видалення, чи повна модернізація,
		   чому не радиться його використовувати.
		   \paragraph Ресурси
		   Source: https://www.youtube.com/watch?v=PQlZI-QoM2A\n
		   \paragraph Приклад
		   \code{.cpp}
		   RC4 rc4;							//Створюю об'єкт ГВЧ
		   char key[100];						//Створюю ключ
		   rc4.crypto_srand(key, 100);			//Встановлюю ключ
		   int BUFSIZe = 100;
		   char output[BUFSIZe];				//Створюю масив під результат
		   rc4.crypto_rand(output, BUFSIZe);	//Генерую результат
		   \endcode
		*/

			/*!
			   \fn ALGOR::RANDOM::RC4::crypto_srand(const byte1_t *, byte4_t)
			   \brief Встановлює ключ генерації
			   \details Приймає ключ і розраховує з нього ключ генерації
			   \param[in] key Ключ, що встановлюється
			   \param[in] ksize Розмір ключа
			   \since v0.1.0.0 commit 88415c
			   \paragraph Приклад
			   \code{.cpp}
			   RC4 rc4;					//Створюю об'єкт ГВЧ
			   char key[100];				//Створюю ключ
			   rc4.crypto_srand(key, 100);	//Встановлюю ключ
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::RANDOM::RC4::crypto_rand(byte1_t *, byte4_t)
			   \brief Генерує значення
			   \details Генерує масив вихідних зашифрованих значень, які можна
			   використовувати, як згенеровані ГВЧ.
			   \param[out] output Генерує масив вихідних елементів
			   \param size Розмір масиву вихідних елементів
			   \since v0.1.0.0 commit 88415c
			   \paragraph Приклад
			   \code{.cpp}
			   int BUFSIZe = 100;
			   char output[BUFSIZe];				//Створюю масив під результат
			   rc4.crypto_rand(output, BUFSIZe);	//Генерую результат
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \var ALGOR::RANDOM::RC4::Sbox
			   \brief Ключ генерації
			   \since v0.1.0.0 commit 88415c
			 */

		/*!
		   \class ALGOR::RANDOM::MersenneTwister
		   \brief Складний ГПВЧ, що базується на властивостях простих чисел Мерсенна
		   \details Вихор Мерсенна — ГПВЧ, розроблений у 1997 році японськими
		   вченими Макото Мацумото та Такудзі Нісімурою. Вихор Мерсенна ґрунтується
		   на властивостях простих чисел Мерсенна та забезпечує швидке генерування
		   високоякісних за критерієм випадковості псевдовипадкових чисел.
		   \since v0.1.0.0 commit 88415c
		   \deprecated На даному етапі розробка даного ГВЧ заморожена. Нехай
		   він і краще за Лінійні ГПВЧ, його ще не доведено до відлагодженого стану.
		   Його ще й досі складно використовувати. У майбутньому можлива повна
		   зміна сигнатур методів у класі. Чи його повне видалення.
		   \paragraph Ресурси
		   Source: https://www.agner.org/random/\n
		   \paragraph Приклад
		   \code{.cpp}
		   //Створюю об'єкт ГВЧ
		   using namespace ALGOR::RANDOM;

		   MersenneTwister RanGen(getMemoryCell(32));

		   //Заповнюю масив числами від 10 до 100
		   for (asize_t i = 0; i < array_size; i++)
		   {
			   array[i] = RanGen.IRandom(10, 100);
		   }
		   \endcode
		 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::MersenneTwister(byte4_t)
			   \brief Конструктор класу ГПВЧ Вихор Марсенна (встановлює сі́м'я)
			   \details Встановлює сі́м'я та проводить ініціалізацію послідовності,
			   що буде генеруватися.
			   \param[in] seed Сі́м'я генерації
			   \since v0.1.0.0 commit 88415c
			   \paragraph Приклад
			   \code{.cpp}
			   MersenneTwister RanGen(getMemoryCell(32));
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::RandomInit(byte4_t)
			   \brief Ініціалізація ГПВЧ
			   \details Використовується при перевстановленні семені ГПВЧ.
			   \param[in] seed Сі́м'я генерації
			   \since v0.1.0.0 commit 88415c
			   \paragraph Приклад
			   \code{.cpp}
			   RanGen.RandomInit(getMemoryCell(32));
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::rand()
			   \brief Метод генеації даних на усьому можливому діапазоні
			   \details Генерує числа на увесь можливий діапазон змінної. Цей метод
			   спеціально було створено під сумісність з функцією тестування ГПВЧ.
			   \since v0.1.3.0 commit ca0704
			   \warning Цей метод було написано лише для функції тестування ГПВЧ. Не
			   використовуйте його, якщо у вас є обмеження на число, що має бути
			   згенероване. Для цього використовуйте метод
			   MersenneTwister::IRandom, що спеціально для цього й створювався.
			   \warning А також, якщо Вам потрібно згенерувати число на усьому
			   діапазоні, то краще використати MersenneTwister::BRandom, щоб уникнути
			   додаткових розрахунків.
			   \deprecated Буде видалено після завершення тестування ГПВЧ
			   \return згенероване число
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::IRandom(byte4_t, byte4_t)
			   \brief Метод генерація числа у заданому діапазоні
			   \details Генерує число у заданому діапазоні.
			   \param[in] min Мінімальне число діапазону
			   \param[in] max Максимальне число діапазону
			   \since v0.1.0.0 commit 88415c
			   \return згенероване число у заданому діапазоні
			   \paragraph Приклад
			   \code{.cpp}
			   array[0] = RanGen.IRandom(10, 100);
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::IRandomX(byte4_t, byte4_t)
			   \brief Більш точніший метод генерація числа у заданому діапазоні
			   \details Є аналогом методу MersenneTwister::IRandom, що генерує
			   число за складнішим алгоритмом, а саме число є більш точнішим.
			   \param[in] min Мінімальне число діапазону
			   \param[in] max Максимальне число діапазону
			   \since v0.1.0.0 commit 88415c
			   \return точне згенероване число у заданому діапазоні
			   \paragraph Приклад
			   \code{.cpp}
			   array[0] = RanGen.IRandomX(10, 100);
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::Random()
			   \brief Метод генеріції числа з плаваючою комою
			   \details Генерує числа з плаваючою комою
			   \since v0.1.0.0 commit 88415c
			   \warning Цей метод генерує числа від 0 до 1, тобто всі
			   згенеровані числа будуть меншими від одиниці
			   \return число з плаваючою комою
			   \paragraph Приклад
			   \code{.cpp}
			   array[0] = RanGen.Random();
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::BRandom()
			   \brief Метод генерації випадкових бітів
			   \details Генерує випадкові біти у змінній з чотирьох байт, що дозволяє
			   згенерувати 32-бітове число на всьому діапазоні.
			   \since v0.1.0.0 commit 88415c
			   \note Може слугувати аналогом методу MersenneTwister::rand, але той
			   метод є надстройкою над MersenneTwister::IRandom для функції тестування
			   ГПВЧ, що викликає додаткові розрахунки та витрати ресурсів. Якщо
			   потрібно відразу згенерувати якесь число на усьому діапазоні, то краще
			   обирати цей метод.
			   \return згенероване число на всьому діапазоні
			   \paragraph Приклад
			   \code{.cpp}
			   array[0] = RanGen.BRandom();
			   \endcode
			   \paragraph Реалізація
			 */

			/*!
			   \fn ALGOR::RANDOM::MersenneTwister::Init0(byte4_t)
			   \brief Базова процедура ініціалізації
			   \param[in] seed Сі́м'я генерації
			   \since v0.1.0.0 commit 88415c
			   \paragraph Реалізація
			 */

			/*!
			   \var ALGOR::RANDOM::MersenneTwister::mersenne_twister
			   \brief Вектор стану
			   \since v0.1.0.0 commit 88415c
			 */

			/*!
			   \var ALGOR::RANDOM::MersenneTwister::mersenne_twister_index
			   \brief Індекс у векторі стану (MersenneTwister::mersenne_twister)
			   \since v0.1.0.0 commit 88415c
			 */

			/*!
			   \var ALGOR::RANDOM::MersenneTwister::LastInterval
			   \brief Довжина останнього інтервалу для MersenneTwister::IRandomX
			   \since v0.1.0.0 commit 88415c
			 */

			/*!
			   \var ALGOR::RANDOM::MersenneTwister::RejectionLimit
			   \brief Ліміт відхилень, який використовує MersenneTwister::IRandomX
			   \since v0.1.0.0 commit 88415c
			 */

		/*!
		   \fn ALGOR::RANDOM::test_random_on_Pearsons_coefficient(ubit32_t, ubit32_t)
		   \brief Функція тестування ГПВЧ на рівномірність
		   \details Тестує ГПВЧ на рівномірність генерації чисел, використовуючи
		   коефіціент узгодженості Пірсона.
		   \tparam Generator Клас алгоритму ГПВЧ, що потрібно протестувати.
		   \param[in] left_limit Мінімальне число діапазону генерації
		   при тестуванні
		   \param[in] right_limit Максимальне число діапазону генерації
		   при тестуванні
		   \since v0.1.3.0 commit ca0704
		   \warning ГВЧ RANDOM::RC4 поки не можна протестувати, так як його не
		   підготовлено до використання данною функцією тестування, та й сама
		   функція не компілюється під цей алгоритм.
		   \return коефіціент узгодженості Пірсона
		   \paragraph Приклад
		   \code{.cpp}
		   cout << RANDOM::tester<RANDOM::LCM>(0, 999999) << "\n";
		   cout << RANDOM::tester<RANDOM::MersenneTwister>(0, 999999) << "\n";
		   //print 78.6892
		   //print 80.2694
		   \endcode
		   \remark Як можна побачити з прикладу, RANDOM::LCM генерує
		   числа більш рівномірно. Однак це не значить, що він є кращим... Як вже
		   було сказано, ГПВЧ Вихор Марсена є швидшим <del>(хоча й використовує
		   набагато більше операцій та розрахунків)</del> та якіснішим. А отримані
		   результати є лише випадковістю. Інколи краще генерує RANDOM::LCM, а
		   інколи RANDOM::MersenneTwister, через що можна зробити висновок, що вони
		   однаково якісно генерують числа <del>(чи може просто добре підібрані
		   коефіціенти для RANDOM::LCM)</del>. Для функції генерації
		   ALGOR::generate_struct структури масиву ALGOR::Array все ж таки було
		   обрано RANDOM::LCM, так як він набагато легший у реалізації та
		   розумінні, а працює так само якісно, як і RANDOM::MersenneTwister.
		   \paragraph Реалізація
		 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                 ALGOR_ARRAY                                 *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

/*!
Array
*/

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                ALGOR_SORTING                                *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

/*!
Sorting
*/

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                 ALGOR_MATRIX                                *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

/*!
Matrix
*/

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                  ALGOR_HEAP                                 *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

/*!
Heap
*/

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                  ALGOR_LIST                                 *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

/*!
List
*/