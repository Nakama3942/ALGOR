/* **************************   DOCUMENTATION.dox   ************************** *
 * --------------------------------------------------------------------------- *
 *                                                                             *
 * Copyright © 2021-2022 Kalynovsky Valentin. All rights reserved.             *
 *                                                                             *
 * Licensed under the Apache License, Version 2.0 (the "License");             *
 * you may not use this file except in compliance with the License.            *
 * You may obtain a copy of the License at                                     *
 *                                                                             *
 *     http://www.apache.org/licenses/LICENSE-2.0                              *
 *                                                                             *
 * Unless required by applicable law or agreed to in writing, software         *
 * distributed under the License is distributed on an "AS IS" BASIS,           *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    *
 * See the License for the specific language governing permissions and         *
 * limitations under the License.                                              *
 *                                                                             *
 * --------------------------------------------------------------------------- *
 * *************************************************************************** *
 */

/*!
  \namespace ALGOR
  \brief The global namespace of the entire project
  \details Intended for storage of all implemented functionality of the project.
  \note Better not to use with std or conflicts may occur.
  \since v0.1.2.0 commit 2fa93b

  \author Kalynovsky Valentin
  \version 1.0.0.0
  \copyright Copyright © 2021-2022 Kalynovsky Valentin. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License")

  \todo Implement the ALGOR_MATRIX section
  \todo Implement the ALGOR_HEAP section
  \todo Implement the ALGOR_LIST section

  \example sort_global.cpp
  \example sort_test.cpp
  \example Algor_core.cpp
  \example Algor_printer.cpp
  \example Algor_exception.cpp
  \example Algor_random.cpp
  \example Algor_ArrayProcessing.cpp
  \example Algor_ArrayData.cpp
  \example Algor_ArraySort.cpp
 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                  ALGOR_CORE                                 *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

	/*!
	   \typedef ALGOR::byte1_t
	   \brief Alias ​​for char <i>(1 byte)</i>
	   \details Usually used to specify the term type. Can store a number from
	   <b>0</b> to <b>255</b>, or from <b>-128</b> to <b>+127</b>.
	   \since v0.1.3.0 commit b50b4a
	   \attention If this type is indeed used for strings, then do not forget
	   to specify "*" (pointer) in front of the name of the string name, since
	   this type does not completely replace char with string. It's just a
	   normal alias.
	 */
	 
	/*!
	   \typedef ALGOR::byte2_t
	   \brief Alias ​​for short <i>(2 bytes)</i>.
	   \details It is usually used when storing short numbers from <b>0</b>
	   to <b>65'535</b>, or from <b>-32'768</b> to <b>+32'767</b>.
	   \since v0.1.3.0 commit b50b4a
	 */

	/*!
	   \typedef ALGOR::byte4_t
	   \brief Alias ​​for long <i>(4 bytes)</i>.
	   \details Usually used when storing numbers. Can store from <b>0</b>
	   to <b>4'294'967'295</b>, or from <b>-2'147'483'648</b>
	   to <b>+2'147'483'647</b>.
	   \since v0.1.3.0 commit b50b4a
	   \note It can also fully replace the int type, as it is also designed
	   for 4 bytes. But if you run the program on a computer with an intel
	   i386 processor or earlier, only 2 bytes will be allocated under int
	   and on those processors int is an alias for short. Due to such a vague
	   concept of the int type, it is not used anywhere in the library, but
	   clear types such as short or long are used.
	 */

	/*!
	   \typedef ALGOR::byte8_t
	   \brief Alias ​​for long long <i>(8 bytes)</i>.
	   \details Is an extension of the long type by two times and is
	   calculated for numbers from <b>0</b>
	   to <b>18'446'744'073'709'551'615</b>,
	   or from <b>-9'223'372'036'854'775'808</b>
	   to <b>+9'223'372'036'854'775'807</b>.
	   \since v0.1.3.0 commit b50b4a
	 */

	/*!
	   \typedef ALGOR::sbit8_t
	   \brief Alias ​​for signed char <i>(1 byte)</i>.
	   \details Similar to ordinary char, but can take values ​​only from
	   <b>-128</b> to <b>+127</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::sbit16_t
	   \brief Alias ​​for signed short <i>(2 bytes)</i>.
	   \details Similar to the usual short, but can take values ​​only from
	   <b>-32'768</b> to <b>+32'767</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::sbit32_t
	   \brief Alias ​​for signed long <i>(4 bytes)</i>.
	   \details Similar to regular long, but can take values ​​only from
	   <b>-2'147'483'648</b> to <b>+2'147'483'647</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::sbit64_t
	   \brief Alias ​​for signed long long <i>(8 bytes)</i>.
	   \details Similar to the usual long long, but can take values ​​only from
	   <b>-9'223'372'036'854'775'808</b> to <b>+9'223'372'036'854'775'807</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::ubit8_t
	   \brief Alias ​​for unsigned char <i>(1 byte)</i>.
	   \details Similar to ordinary char and unlike signed char, it can take
	   values ​​only from <b>0</b> to <b>255</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::ubit16_t
	   \brief Alias ​​for unsigned short <i>(2 bytes)</i>.
	   \details Similar to the usual short and unlike the signed short, it can
	   take values ​​only from <b>0</b> to <b>65'535</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::ubit32_t
	   \brief Alias ​​for unsigned long <i>(4 bytes)</i>.
	   \details Similarly to the usual long and unlike the signed long, it can
	   take values ​​only from <b>0</b> to <b>4'294'967'295</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::ubit64_t
	   \brief Alias ​​for unsigned long long <i>(8 bytes)</i>.
	   \details Similarly to the usual long long and unlike signed long long can
	   take values ​​only from <b>0</b> to <b>18'446'744'073'709'551'615</b>.
	   \since v0.1.0.0 commit 0d3195
	 */

	/*!
	   \typedef ALGOR::fbit32_t
	   \brief Alias ​​for float <i>(4 bytes)</i>.
	   \details Unlike all previous types that can only store integers, the
	   <i>float</i> can store floating-point numbers. You can write both positive
	   and negative numbers in the cell. possible range of stored numbers is
	   from <b>+/-3.4E-38</b> to <b>3.4E+38</b>.
	   \since v0.1.2.0 commit 1981d6
	 */

	/*!
	   \typedef ALGOR::fbit64_t
	   \brief Alias ​​for double <i>(8 bytes)</i>.
	   \details Extends the <i>float</i>, doubling the precision and size.
	   Possible range of stored numbers is from <b>+/-1.7E-308</b> to
	   <b>1.7E+308</b>.
	   \since v0.1.2.0 commit 1981d6
	 */

	/*!
	   \typedef ALGOR::fbit128_t
	   \brief Alias ​​for long double <i>(16 bytes)</i>.
	   \details Extends the type <i>double</i>, doubling the precision and size. 
	   \since v0.1.3.0 commit b6349a
	 */

	/*!
	   \typedef ALGOR::asize_t
	   \brief Alias ​​for defining the <i>"array size"</i>.
	   \details Usually, this type is used when you need to specify the size of
	   an array or a position in an array. Since numbering starts at 0 and there
	   are no negative array sizes or position numbers, it is possible to cast
	   the type from <i>int</i> to <i>unsigned int</i>. In addition, <b>65'535</b>
	   array cells are not always enough. Sometimes more is needed, for example,
	   a million or a billion. More than a billion does not make sense to create
	   data structures, so the ideal choice among <i>short</i>, <i>long</i> and
	   <i>long long</i> is <i>long</i>. That's why <i>asize_t</i> is an alias to
	   ALGOR::ubit32_t.
	   \since v0.1.0.0 commit 89658e
	 */

	/*!
	   \typedef ALGOR::memcell_t
	   \brief An alias for the computed <i>memory cell</i>.
	   \details Used only in the ALGOR::getMemoryCell, as a type of cell that
	   stores the calculated number. 
	   \since v0.1.1.3 commit b4cdc9
	   \attention It is a service type and it is better to use ALGOR::ubit64_t.
	 */

	/*!
	   \fn ALGOR::swap(type_value &, type_value &)
	   \brief Swaps two elements
	   \details The function accepts two values, which must be replaced by
	   places. After the function is executed, the first memory cell will store
	   the second value, and the second - the first. An additional memory cell
	   is used to perform the algorithm.
	   \tparam type_value The type of elements that change places
	   \param[in, out] firstNumber The first item to replace
	   \param[in, out] secondNumber The second element to replace
	   \since v0.0.0.1
	   \test
	   \snippet Algor_core.cpp swap
	 */

	/*!
	   \fn ALGOR::minimum(type_value, type_value)
	   \brief Finds the smallest value of the two given values
	   \details The function takes two values ​​and compares them. If the first
	   number is smaller than the second, the function returns the first number,
	   otherwise - the second.
	   \tparam type_value The type of elements from which the smallest value is selected
	   \param[in] firstNumber The first value per sample
	   \param[in] secondNumber The second value per sample
	   \since v0.1.1.4 commit 090b06
	   \return the smaller value of the two given
	   \sa ALGOR::maximum(type_value, type_value)
	   \test
	   \snippet Algor_core.cpp minimum
	 */

	/*!
	   \fn ALGOR::maximum(type_value, type_value)
	   \brief Finds the largest value of the two given values
	   \details The function takes two values ​​and compares them. If the first
	   number is greater than the second, the function returns the first number,
	   otherwise - the second.
	   \tparam type_value The type of elements from which the largest value is selected
	   \param[in] firstNumber The first value per sample
	   \param[in] secondNumber The second value per sample
	   \since v0.1.1.4 commit 090b06
	   \return the larger value of the two given 
	   \sa ALGOR::minimum(type_value, type_value)
	   \test
	   \snippet Algor_core.cpp maximum
	 */

	/*!
	   \fn ALGOR::getMemoryCell(memcell_t, memcell_t)
	   \brief Returns a random number; analog time(NULL)
	   \details This method allocates memory for 10 memory cells. It is impossible
	   to guess where exactly the system will allocate memory, and it is also
	   impossible to guess which program and which data previously recorded here,
	   so this is the most real generator of random numbers. So far, the
	   generation of arrays has not been perfected, but as a generator of a large
	   number instead of time(NULL), it is quite possible to use it. From ten
	   random numbers, the function calculates the number to be returned.
	   \remark The function can be set to a bit shift. If the function is used
	   instead of time(NULL) and the result is passed to another function that
	   only accepts a four-byte value, you can specify a right shift of 32 bits
	   (4 bytes) and then the function will return the 4 most significant bytes.
	   \param[in] right_adjust Right shift
	   \param[in] left_adjust Left shift
	   \since v0.1.1.3 commit b4cdc9
	   \retval cell - calculated random number
	   \test
	   \snippet Algor_core.cpp mem
	 */

	 /*!
	   \struct ALGOR::Array
	   \brief A structure that simulates an array
	   \details Intended for storing a pointer to a dynamic array and its size.
	   \tparam type_array The type of elements stored in the array
	   \since v0.0.1.0 commit 979bf4
	   \test
	   \snippet Algor_core.cpp array struct
	 */

		/*!
		   \var ALGOR::Array::array
		   \brief Array pointer
		   \since v0.0.1.0 commit 979bf4
		 */

		/*!
		   \var ALGOR::Array::array_size
		   \brief Array size
		   \since v0.0.1.0 commit 979bf4
		 */

	/*!
	   \fn ALGOR::create_struct(const asize_t &, bool)
	   \brief Creates a structure with a pointer to an array
	   \details Saves the size of the array, allocates memory for this same array
	   and returns a pointer to the array structure.
	   \throw ALGOR::EXCEPTION_SET::void_data
	   \tparam type_array The type of elements to be stored in the array
	   \param[in] SIZE The size of the created array
	   \param[in] mem_allocation Logical flag, whether you need to allocate memory for the array
	   \retval Array<type_array>* - a pointer to the created structure
	   \since v0.1.0.0 commit 85698d
	   \remark If you have already allocated memory for the array, then the
	   structure does not need to re-allocate memory. The structure only stores
	   the size of the array and the pointer to this array itself. Therefore, in
	   this case, the <i>mem_allocation</i> to <i>false</i> and after that save
	   the pointer to the array in the structure. In other cases,
	   <i>mem_allocation</i> it is better not to change.
	   \test
	   \snippet Algor_core.cpp create_struct
	 */

	/*!
	   \fn ALGOR::generate_struct(Array<type_array> *&, const sbit64_t &, const sbit64_t &, const ubit64_t, const ubit32_t)
	   \brief Generates random values ​​in an array structure
	   \details Generates values ​​from the specified range in an array structure.
	   If you set <i>denominator</i>, you can get multiples or small values ​​of
	   the data.
	   \throw ALGOR::EXCEPTION_SET::division_by_zero
	   \tparam type_array Specifies what type of numbers will be generated in the
	   array structure
	   \param[in, out] Array The array structure in which to generate the data
	   \param[in] min_limit Minimum possible generated value 
	   \param[in] max_limit Maximum possible generated value 
	   \param[in] seed Generator seed
	   \param[in] denominator Divider for generating <i>float</i> data
	   \since v0.0.0.1
	   \note In case ALGOR::getMemoryCell, you can set the generation family
	   yourself.
	   \test
	   \snippet Algor_core.cpp generate_struct
	 */

	/*!
	   \fn ALGOR::remove_struct(Array<type_array> *&)
	   \brief Deletes an array and a pointer to a structure
	   \details Frees memory from the array stored in the structure and frees the
	   structure itself.
	   \throw ALGOR::EXCEPTION_SET::void_data
	   \tparam type_array The type of elements stored in the array
	   \param[in, out] Array The array to delete
	   \result The pointer to the structure after calling this function will
	   point to <i>nullptr</i>.
	   \since v0.1.0.0 commit 48aa64
	   \test
	   \snippet Algor_core.cpp remove_struct
	 */

	/*!
	   \interface ALGOR::Printer
	   \brief Printer-interface designed to implement information output
	   functionality
	   \details It is an interface consisting of only one virtual method that is
	   designed to output information. Since this project is unique in the sense
	   that no other library (even a standard one) is used and the author writes
	   his own implementation of the algorithms - therefore it is impossible to
	   use the iostream class, which makes the implementation of the printer
	   impossible. The author will need to write his own input-output class from
	   the beginning, and in the conditions of the popularity of graphical
	   interfaces, this is not optimal and relevant. It is better to let the
	   programmer himself implement input-output. In addition, this method is
	   universal: it can be used both in console and graphical programs. If I
	   tried to write an implementation myself, it would be specialized either
	   for the console or for the graphics. This is what prompted me to write the
	   interface, not the class.
	   \warning So that there are no warnings "Potential leak of memory pointed
	   to by 'name' [clang-analyzer-cplusplus.NewDeleteLeaks]" (about a potential
	   memory leak) - you need to create a static <i>printer</i>!
	   \since v0.1.2.0 commit 2fa93b
	   \remark I advise you to use the following implementation for the console
	   program:
	   \test
	   \snippet Algor_printer.cpp printer
	   This class does not store an array, but a pointer to a pointer to an array
	   structure. Therefore, it is enough to pass the pointer to the structure
	   once to the class and that's it. Further, you can simply change the
	   pointers to other structures with other arrays and do not need to
	   re-transfer them to this class. It will itself keep track of which pointer
	   is stored in the structure pointer.
	 */

		/*!
		   \fn ALGOR::Printer::print()
		   \brief Method for outputting information
		   \since v0.1.2.0 commit 2fa93b
		   \test
		   \snippet Algor_printer.cpp print
		 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                 ALGOR_MATRIX                                *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

/*!
  \todo Зробити розділ ALGOR_MATRIX
 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                  ALGOR_HEAP                                 *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

/*!
  \todo Зробити розділ ALGOR_HEAP
 */

/* *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 * --------------------------------------------------------------------------- *
 *                                  ALGOR_LIST                                 *
 * --------------------------------------------------------------------------- *
 * *****/---/+++++-/%/-+-+-+-/%/-+-+-+-&&&-+-+-+-/%/-+-+-+-/%/-+++++/---/***** *
 */

/*!
  \todo Зробити розділ ALGOR_LIST
 */